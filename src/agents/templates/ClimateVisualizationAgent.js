/**
 * Climate Visualization Agent Template
 * Generated by Agent Factory for Seawater Platform
 * 
 * This template generates specialized agents for creating interactive climate data visualizations
 * with automated chart generation, educational content, and accessibility features.
 */

const AgentFactory = require('../AgentFactory');

class ClimateVisualizationAgent extends AgentFactory {
    constructor() {
        super();
        this.domain = 'climate-visualization';
        
        // Visualization patterns specific to climate data
        this.visualizationPatterns = {
            chartTypes: {
                risk_meter: 'RiskScoreWidget',
                time_series: 'HistoricalTrendChart',
                risk_comparison: 'MultiPropertyComparison',
                hazard_breakdown: 'HazardAttributionChart',
                geographic: 'RiskHeatMap',
                projection: 'FutureProjectionChart'
            },
            colorSchemes: {
                risk_levels: ['#22c55e', '#eab308', '#f97316', '#ef4444', '#7c2d12'],
                temperature: ['#3b82f6', '#ffffff', '#ef4444'],
                precipitation: ['#fef3c7', '#3b82f6', '#1e40af'],
                elevation: ['#22c55e', '#eab308', '#8b5cf6']
            },
            accessibilityFeatures: ['colorBlindFriendly', 'screenReader', 'keyboardNavigation', 'highContrast']
        };
        
        // Educational content templates
        this.educationalTemplates = {
            risk_explanations: true,
            data_source_attribution: true,
            methodology_disclosure: true,
            actionable_guidance: true
        };
    }

    /**
     * Generate interactive risk visualization components
     */
    generateRiskVisualizationComponent(config) {
        const {
            componentName,
            chartType,
            hazardTypes = ['flood', 'wildfire', 'hurricane', 'earthquake'],
            interactiveFeatures = ['tooltips', 'zoom', 'filter'],
            educationalContent = true,
            accessibility = true
        } = config;

        const componentCode = `import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { 
    LineChart, Line, AreaChart, Area, BarChart, Bar, 
    XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
    PieChart, Pie, Cell, RadialBarChart, RadialBar
} from 'recharts';
import { Info, TrendingUp, TrendingDown, AlertTriangle, Eye, EyeOff } from 'lucide-react';
import { clsx } from 'clsx';
import { motion, AnimatePresence } from 'framer-motion';

interface ${componentName}Props {
    data: ClimateRiskData;
    hazardTypes?: HazardType[];
    showEducation?: boolean;
    showProjections?: boolean;
    interactive?: boolean;
    accessibility?: AccessibilityOptions;
    onHazardSelect?: (hazard: HazardType) => void;
    onTimeRangeSelect?: (range: TimeRange) => void;
    className?: string;
}

interface ClimateRiskData {
    location: {
        latitude: number;
        longitude: number;
        address?: string;
    };
    currentRisks: Record<HazardType, RiskScore>;
    historicalData?: TimeSeriesData[];
    projections?: ProjectionData[];
    dataQuality: DataQualityMetrics;
    lastUpdated: string;
}

interface RiskScore {
    score: number;
    level: 'LOW' | 'MODERATE' | 'HIGH' | 'VERY_HIGH' | 'EXTREME';
    confidence: number;
    sources: string[];
    trend?: 'increasing' | 'decreasing' | 'stable';
}

interface DataQualityMetrics {
    overall: number;
    freshness: number;
    completeness: number;
    accuracy: number;
    consistency: number;
}

interface AccessibilityOptions {
    colorBlindFriendly?: boolean;
    screenReaderOptimized?: boolean;
    highContrast?: boolean;
    reducedMotion?: boolean;
}

// Color schemes for accessibility
const COLOR_SCHEMES = {
    default: {
        risk: ['#22c55e', '#eab308', '#f97316', '#ef4444', '#7c2d12'],
        trend: { increasing: '#ef4444', decreasing: '#22c55e', stable: '#6b7280' }
    },
    colorBlind: {
        risk: ['#0066cc', '#ffcc00', '#ff6600', '#cc0000', '#660000'],
        trend: { increasing: '#cc0000', decreasing: '#0066cc', stable: '#666666' }
    },
    highContrast: {
        risk: ['#000000', '#444444', '#777777', '#aaaaaa', '#ffffff'],
        trend: { increasing: '#000000', decreasing: '#ffffff', stable: '#777777' }
    }
};

// Educational content for each hazard type
const HAZARD_EDUCATION = {
    flood: {
        description: 'Flooding occurs when water overflows onto normally dry land. This can happen from heavy rainfall, storm surge, or river overflow.',
        riskFactors: ['Proximity to water bodies', 'Low elevation', 'Poor drainage', 'Historical flood patterns'],
        mitigation: ['Flood insurance', 'Elevated utilities', 'Proper drainage', 'Emergency planning']
    },
    wildfire: {
        description: 'Wildfires are uncontrolled fires that spread rapidly through vegetation. They can be caused by natural factors or human activity.',
        riskFactors: ['Dry vegetation', 'High temperatures', 'Low humidity', 'Strong winds', 'Proximity to wildland'],
        mitigation: ['Defensible space', 'Fire-resistant materials', 'Evacuation planning', 'Insurance coverage']
    },
    hurricane: {
        description: 'Hurricanes are powerful tropical storms with sustained winds of 74+ mph, bringing wind damage, flooding, and storm surge.',
        riskFactors: ['Coastal location', 'Storm surge zones', 'Wind exposure', 'Historical hurricane paths'],
        mitigation: ['Hurricane straps', 'Impact windows', 'Flood barriers', 'Emergency supplies']
    },
    earthquake: {
        description: 'Earthquakes are sudden ground movements caused by tectonic plate shifts. They can cause structural damage and trigger landslides.',
        riskFactors: ['Proximity to fault lines', 'Soil type', 'Building construction', 'Historical seismic activity'],
        mitigation: ['Seismic retrofitting', 'Earthquake insurance', 'Secure heavy objects', 'Emergency kit']
    }
};

export const ${componentName}: React.FC<${componentName}Props> = React.memo(({
    data,
    hazardTypes = ${JSON.stringify(hazardTypes)},
    showEducation = ${educationalContent},
    showProjections = true,
    interactive = true,
    accessibility = {},
    onHazardSelect,
    onTimeRangeSelect,
    className
}) => {
    // State management
    const [selectedHazard, setSelectedHazard] = useState<HazardType | null>(null);
    const [showEducationalPanel, setShowEducationalPanel] = useState(false);
    const [timeRange, setTimeRange] = useState<'1Y' | '5Y' | '10Y' | '30Y'>('10Y');
    const [chartType, setChartType] = useState<'${chartType}'>('${chartType}');
    
    // Accessibility preferences
    const colorScheme = useMemo(() => {
        if (accessibility.highContrast) return COLOR_SCHEMES.highContrast;
        if (accessibility.colorBlindFriendly) return COLOR_SCHEMES.colorBlind;
        return COLOR_SCHEMES.default;
    }, [accessibility]);

    // Process risk data for visualization
    const processedData = useMemo(() => {
        const riskData = hazardTypes.map(hazard => {
            const riskInfo = data.currentRisks[hazard];
            if (!riskInfo) return null;
            
            return {
                hazard,
                score: riskInfo.score,
                level: riskInfo.level,
                confidence: riskInfo.confidence,
                trend: riskInfo.trend,
                color: getRiskColor(riskInfo.level, colorScheme.risk),
                educationData: HAZARD_EDUCATION[hazard]
            };
        }).filter(Boolean);
        
        return riskData;
    }, [data.currentRisks, hazardTypes, colorScheme]);

    // Historical trend data processing
    const trendData = useMemo(() => {
        if (!data.historicalData) return [];
        
        return data.historicalData
            .filter(item => {
                const date = new Date(item.date);
                const cutoff = new Date();
                const years = parseInt(timeRange.replace('Y', ''));
                cutoff.setFullYear(cutoff.getFullYear() - years);
                return date >= cutoff;
            })
            .map(item => ({
                date: new Date(item.date).toLocaleDateString(),
                ...item.risks
            }));
    }, [data.historicalData, timeRange]);

    // Handle hazard selection
    const handleHazardClick = useCallback((hazard: HazardType) => {
        setSelectedHazard(prev => prev === hazard ? null : hazard);
        if (onHazardSelect) {
            onHazardSelect(hazard);
        }
        
        // Announce to screen readers
        if (accessibility.screenReaderOptimized) {
            const announcement = \`Selected \${hazard} risk data. Score: \${data.currentRisks[hazard]?.score || 'unknown'}\`;
            announceToScreenReader(announcement);
        }
    }, [onHazardSelect, data.currentRisks, accessibility.screenReaderOptimized]);

    // Custom tooltip component
    const CustomTooltip = ({ active, payload, label }: any) => {
        if (!active || !payload || !payload.length) return null;
        
        return (
            <div className="bg-white border border-gray-200 rounded-lg shadow-lg p-4 max-w-sm"
                 role="tooltip"
                 aria-label="Risk data tooltip">
                <h3 className="font-semibold text-gray-900 mb-2">{label}</h3>
                {payload.map((entry: any, index: number) => (
                    <div key={index} className="flex items-center justify-between mb-1">
                        <span className="flex items-center text-sm text-gray-600">
                            <div 
                                className="w-3 h-3 rounded-full mr-2"
                                style={{ backgroundColor: entry.color }}
                                aria-hidden="true"
                            />
                            {entry.dataKey}
                        </span>
                        <span className="text-sm font-medium text-gray-900">
                            {entry.value}
                        </span>
                    </div>
                ))}
                {showEducation && selectedHazard && (
                    <div className="mt-3 pt-3 border-t border-gray-200">
                        <p className="text-xs text-gray-600">
                            {HAZARD_EDUCATION[selectedHazard]?.description}
                        </p>
                    </div>
                )}
            </div>
        );
    };

    // Main chart rendering based on chart type
    const renderChart = () => {
        switch (chartType) {
            case 'risk_meter':
                return (
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        {processedData.map((risk, index) => (
                            <motion.div
                                key={risk.hazard}
                                initial={{ opacity: 0, y: 20 }}
                                animate={{ opacity: 1, y: 0 }}
                                transition={{ delay: index * 0.1 }}
                                className={clsx(
                                    'p-4 rounded-lg border transition-all duration-200',
                                    selectedHazard === risk.hazard 
                                        ? 'border-seawater-primary bg-seawater-primary/5' 
                                        : 'border-gray-200 hover:border-gray-300',
                                    interactive && 'cursor-pointer'
                                )}
                                onClick={() => interactive && handleHazardClick(risk.hazard)}
                                role={interactive ? 'button' : undefined}
                                tabIndex={interactive ? 0 : undefined}
                                onKeyDown={interactive ? (e) => {
                                    if (e.key === 'Enter' || e.key === ' ') {
                                        e.preventDefault();
                                        handleHazardClick(risk.hazard);
                                    }
                                } : undefined}
                                aria-label={interactive ? 
                                    \`\${risk.hazard} risk: \${risk.score} out of 100, \${risk.level} level\` : 
                                    undefined
                                }
                            >
                                <div className="flex items-center justify-between mb-3">
                                    <h3 className="font-medium text-gray-900 capitalize">
                                        {risk.hazard.replace('_', ' ')}
                                    </h3>
                                    {risk.trend && (
                                        <div className="flex items-center text-sm">
                                            {risk.trend === 'increasing' ? (
                                                <TrendingUp className="h-4 w-4 text-red-500" />
                                            ) : risk.trend === 'decreasing' ? (
                                                <TrendingDown className="h-4 w-4 text-green-500" />
                                            ) : (
                                                <div className="h-4 w-4" />
                                            )}
                                        </div>
                                    )}
                                </div>
                                
                                <div className="space-y-3">
                                    <div className="flex items-end space-x-3">
                                        <span className="text-3xl font-bold" style={{ color: risk.color }}>
                                            {risk.score}
                                        </span>
                                        <span className="text-sm text-gray-600 mb-1">
                                            {risk.level.replace('_', ' ')}
                                        </span>
                                    </div>
                                    
                                    <div className="relative">
                                        <div className="h-2 bg-gray-200 rounded-full overflow-hidden">
                                            <div 
                                                className="h-full transition-all duration-500 rounded-full"
                                                style={{ 
                                                    width: \`\${risk.score}%\`,
                                                    backgroundColor: risk.color
                                                }}
                                                role="progressbar"
                                                aria-valuenow={risk.score}
                                                aria-valuemin={0}
                                                aria-valuemax={100}
                                                aria-label={\`\${risk.hazard} risk score\`}
                                            />
                                        </div>
                                    </div>
                                    
                                    <div className="flex items-center justify-between text-sm text-gray-600">
                                        <span>Confidence: {Math.round(risk.confidence * 100)}%</span>
                                        {showEducation && (
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    setSelectedHazard(risk.hazard);
                                                    setShowEducationalPanel(true);
                                                }}
                                                className="flex items-center text-seawater-primary hover:text-seawater-primary-dark"
                                                aria-label={\`Learn more about \${risk.hazard} risk\`}
                                            >
                                                <Info className="h-4 w-4" />
                                            </button>
                                        )}
                                    </div>
                                </div>
                            </motion.div>
                        ))}
                    </div>
                );
            
            case 'time_series':
                return (
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <h3 className="text-lg font-semibold text-gray-900">Historical Risk Trends</h3>
                            <div className="flex space-x-2">
                                {['1Y', '5Y', '10Y', '30Y'].map(range => (
                                    <button
                                        key={range}
                                        onClick={() => setTimeRange(range as any)}
                                        className={clsx(
                                            'px-3 py-1 rounded text-sm font-medium transition-colors',
                                            timeRange === range
                                                ? 'bg-seawater-primary text-white'
                                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                        )}
                                        aria-pressed={timeRange === range}
                                    >
                                        {range}
                                    </button>
                                ))}
                            </div>
                        </div>
                        
                        <div className="h-80">
                            <ResponsiveContainer width="100%" height="100%">
                                <LineChart data={trendData}>
                                    <CartesianGrid strokeDasharray="3 3" />
                                    <XAxis dataKey="date" />
                                    <YAxis domain={[0, 100]} />
                                    <Tooltip content={<CustomTooltip />} />
                                    <Legend />
                                    {hazardTypes.map((hazard, index) => (
                                        <Line
                                            key={hazard}
                                            type="monotone"
                                            dataKey={hazard}
                                            stroke={colorScheme.risk[index % colorScheme.risk.length]}
                                            strokeWidth={2}
                                            dot={{ r: 4 }}
                                            name={hazard.replace('_', ' ')}
                                        />
                                    ))}
                                </LineChart>
                            </ResponsiveContainer>
                        </div>
                    </div>
                );
            
            case 'hazard_breakdown':
                return (
                    <div className="space-y-4">
                        <h3 className="text-lg font-semibold text-gray-900">Risk Breakdown by Hazard</h3>
                        <div className="h-80">
                            <ResponsiveContainer width="100%" height="100%">
                                <PieChart>
                                    <Pie
                                        data={processedData}
                                        cx="50%"
                                        cy="50%"
                                        labelLine={false}
                                        label={({ hazard, score }) => \`\${hazard}: \${score}\`}
                                        outerRadius={80}
                                        fill="#8884d8"
                                        dataKey="score"
                                    >
                                        {processedData.map((entry, index) => (
                                            <Cell key={\`cell-\${index}\`} fill={entry.color} />
                                        ))}
                                    </Pie>
                                    <Tooltip content={<CustomTooltip />} />
                                </PieChart>
                            </ResponsiveContainer>
                        </div>
                    </div>
                );
            
            default:
                return <div>Chart type not supported: {chartType}</div>;
        }
    };

    // Educational panel component
    const EducationalPanel = () => (
        <AnimatePresence>
            {showEducationalPanel && selectedHazard && (
                <motion.div
                    initial={{ opacity: 0, x: 300 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: 300 }}
                    className="fixed right-0 top-0 h-full w-96 bg-white shadow-lg z-50 overflow-y-auto"
                    role="dialog"
                    aria-modal="true"
                    aria-labelledby="education-panel-title"
                >
                    <div className="p-6">
                        <div className="flex items-center justify-between mb-4">
                            <h2 id="education-panel-title" className="text-xl font-semibold text-gray-900 capitalize">
                                {selectedHazard.replace('_', ' ')} Risk
                            </h2>
                            <button
                                onClick={() => setShowEducationalPanel(false)}
                                className="text-gray-500 hover:text-gray-700"
                                aria-label="Close education panel"
                            >
                                ✕
                            </button>
                        </div>
                        
                        {HAZARD_EDUCATION[selectedHazard] && (
                            <div className="space-y-6">
                                <section>
                                    <h3 className="font-medium text-gray-900 mb-2">What is this risk?</h3>
                                    <p className="text-gray-700 text-sm">
                                        {HAZARD_EDUCATION[selectedHazard].description}
                                    </p>
                                </section>
                                
                                <section>
                                    <h3 className="font-medium text-gray-900 mb-2">Risk Factors</h3>
                                    <ul className="text-sm text-gray-700 space-y-1">
                                        {HAZARD_EDUCATION[selectedHazard].riskFactors.map((factor, index) => (
                                            <li key={index} className="flex items-start">
                                                <span className="w-2 h-2 bg-seawater-primary rounded-full mt-2 mr-3 flex-shrink-0" />
                                                {factor}
                                            </li>
                                        ))}
                                    </ul>
                                </section>
                                
                                <section>
                                    <h3 className="font-medium text-gray-900 mb-2">Mitigation Strategies</h3>
                                    <ul className="text-sm text-gray-700 space-y-1">
                                        {HAZARD_EDUCATION[selectedHazard].mitigation.map((strategy, index) => (
                                            <li key={index} className="flex items-start">
                                                <span className="w-2 h-2 bg-green-500 rounded-full mt-2 mr-3 flex-shrink-0" />
                                                {strategy}
                                            </li>
                                        ))}
                                    </ul>
                                </section>
                            </div>
                        )}
                    </div>
                </motion.div>
            )}
        </AnimatePresence>
    );

    return (
        <div className={clsx('w-full', className)}>
            {/* Data Quality Indicator */}
            <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                <div className="flex items-center justify-between mb-2">
                    <h3 className="text-sm font-medium text-gray-700">Data Quality</h3>
                    <span className={clsx(
                        'text-sm font-medium',
                        data.dataQuality.overall >= 0.8 ? 'text-green-600' :
                        data.dataQuality.overall >= 0.6 ? 'text-yellow-600' : 'text-red-600'
                    )}>
                        {Math.round(data.dataQuality.overall * 100)}%
                    </span>
                </div>
                <div className="grid grid-cols-4 gap-2 text-xs text-gray-600">
                    <div>Fresh: {Math.round(data.dataQuality.freshness * 100)}%</div>
                    <div>Complete: {Math.round(data.dataQuality.completeness * 100)}%</div>
                    <div>Accurate: {Math.round(data.dataQuality.accuracy * 100)}%</div>
                    <div>Consistent: {Math.round(data.dataQuality.consistency * 100)}%</div>
                </div>
            </div>

            {/* Main Visualization */}
            <div className="mb-6">
                {renderChart()}
            </div>

            {/* Data Attribution */}
            <div className="text-sm text-gray-500">
                <p>
                    Data sources: {Object.values(data.currentRisks)
                        .flatMap(risk => risk.sources)
                        .filter((source, index, array) => array.indexOf(source) === index)
                        .join(', ')
                    }
                </p>
                <p>Last updated: {new Date(data.lastUpdated).toLocaleDateString()}</p>
            </div>

            {/* Educational Panel */}
            {showEducation && <EducationalPanel />}
        </div>
    );
});

${componentName}.displayName = '${componentName}';

// Helper functions
function getRiskColor(level: string, colors: string[]): string {
    const levelMap: Record<string, number> = {
        'LOW': 0,
        'MODERATE': 1,
        'HIGH': 2,
        'VERY_HIGH': 3,
        'EXTREME': 4
    };
    return colors[levelMap[level]] || colors[0];
}

function announceToScreenReader(message: string): void {
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'polite');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.className = 'sr-only';
    announcement.textContent = message;
    document.body.appendChild(announcement);
    
    setTimeout(() => {
        document.body.removeChild(announcement);
    }, 1000);
}

export default ${componentName};
`;

        const outputPath = this.outputDir + `/components/${componentName}.tsx`;
        require('fs').writeFileSync(outputPath, componentCode);
        
        console.log(`📊 Generated Climate Visualization Component: ${outputPath}`);
        return outputPath;
    }

    /**
     * Generate educational content agent for climate risk
     */
    generateEducationalContentAgent(config) {
        const {
            agentName = 'ClimateEducationAgent',
            readingLevel = 'grade-8',
            languages = ['en'],
            contentTypes = ['explanations', 'guidance', 'methodology']
        } = config;

        const educationAgentCode = `/**
 * ${agentName} - Automated educational content generation for climate risks
 * Generated by Agent Factory for user education and trust building
 */

const { EventEmitter } = require('events');

class ${agentName} extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.config = {
            readingLevel: '${readingLevel}',
            maxExplanationLength: 150, // words
            languages: ${JSON.stringify(languages)},
            contentTypes: ${JSON.stringify(contentTypes)}
        };
        
        // Educational content templates
        this.templates = {
            riskExplanations: {
                flood: {
                    simple: "Flood risk measures how likely your property is to experience flooding from rain, rivers, or coastal storms.",
                    detailed: "Flood risk assessment combines historical flooding data, rainfall patterns, elevation, and proximity to water bodies to estimate the likelihood and potential severity of flooding at your property.",
                    sources: "This assessment uses FEMA flood maps, NOAA rainfall data, and local topography information."
                },
                wildfire: {
                    simple: "Wildfire risk shows how likely your area is to experience dangerous wildfires that could threaten your property.",
                    detailed: "Wildfire risk analysis considers vegetation density, historical fire patterns, weather conditions, topography, and defensible space around properties to assess fire threat potential.",
                    sources: "Data comes from CAL FIRE, National Interagency Fire Center, and satellite vegetation monitoring."
                },
                hurricane: {
                    simple: "Hurricane risk indicates your exposure to damaging winds, flooding, and storm surge from tropical storms.",
                    detailed: "Hurricane risk assessment examines historical storm tracks, wind speed patterns, storm surge modeling, and property elevation to determine potential hurricane impacts.",
                    sources: "Analysis uses NOAA Hurricane Database, National Hurricane Center data, and storm surge models."
                },
                earthquake: {
                    simple: "Earthquake risk measures the likelihood of ground shaking that could damage your property.",
                    detailed: "Earthquake risk evaluation considers proximity to fault lines, historical seismic activity, soil conditions, and building vulnerability to estimate potential earthquake impacts.",
                    sources: "Data sourced from USGS Earthquake Hazards Program and geological surveys."
                }
            },
            
            mitigationGuidance: {
                flood: [
                    "Consider flood insurance - standard homeowners insurance doesn't cover flood damage",
                    "Elevate utilities and HVAC systems above potential flood levels",
                    "Install sump pumps and backup power systems",
                    "Create proper drainage around your property",
                    "Keep sandbags and emergency supplies ready during flood season"
                ],
                wildfire: [
                    "Create defensible space by clearing vegetation around your home",
                    "Use fire-resistant building materials and landscaping",
                    "Install ember-resistant vents and screens",
                    "Maintain your roof and gutters to prevent ember accumulation",
                    "Develop and practice an evacuation plan with your family"
                ],
                hurricane: [
                    "Install storm shutters or impact-resistant windows",
                    "Secure outdoor furniture and equipment before storms",
                    "Trim trees and remove dead branches that could fall",
                    "Review your insurance coverage for wind and flood damage",
                    "Prepare an emergency kit with supplies for several days"
                ],
                earthquake: [
                    "Secure heavy furniture and appliances to walls",
                    "Install automatic gas shut-off valves",
                    "Retrofit older buildings to current seismic standards",
                    "Keep emergency supplies in easily accessible locations",
                    "Practice earthquake safety procedures with your household"
                ]
            },
            
            methodologyExplanations: {
                dataCollection: "We gather climate and hazard data from authoritative government sources including FEMA, NOAA, USGS, and EPA. These agencies collect and maintain the most comprehensive and reliable environmental data available.",
                
                riskCalculation: "Risk scores combine multiple data sources using scientific weighting methods. We validate information across sources and adjust for local conditions to provide property-specific assessments.",
                
                qualityAssurance: "All data undergoes automated quality checks for freshness, completeness, and consistency. We monitor data sources continuously and flag any quality issues in our assessments.",
                
                uncertainty: "Every risk assessment includes confidence levels based on data availability and agreement between sources. Lower confidence scores indicate areas where more data would improve accuracy."
            }
        };
        
        // Readability metrics for content optimization
        this.readabilityTargets = {
            'grade-6': { maxWordsPerSentence: 12, maxSyllablesPerWord: 1.5 },
            'grade-8': { maxWordsPerSentence: 15, maxSyllablesPerWord: 1.8 },
            'grade-10': { maxWordsPerSentence: 18, maxSyllablesPerWord: 2.1 },
            'college': { maxWordsPerSentence: 22, maxSyllablesPerWord: 2.5 }
        };
    }

    /**
     * Generate contextual risk explanation
     */
    async generateRiskExplanation(hazardType, riskScore, options = {}) {
        try {
            const {
                detailLevel = 'simple',
                includeGuidance = true,
                includeSources = true,
                customContext = {}
            } = options;
            
            const hazardData = this.templates.riskExplanations[hazardType];
            if (!hazardData) {
                throw new Error(\`No educational content available for hazard type: \${hazardType}\`);
            }
            
            // Generate base explanation
            let explanation = hazardData[detailLevel] || hazardData.simple;
            
            // Add risk-level specific context
            const riskContext = this._getRiskLevelContext(riskScore);
            explanation += \` \${riskContext}\`;
            
            // Customize for local context if provided
            if (customContext.location) {
                explanation = this._addLocationContext(explanation, hazardType, customContext.location);
            }
            
            // Build complete educational content
            const educationalContent = {
                hazardType,
                riskScore,
                explanation: this._optimizeReadability(explanation),
                riskLevel: this._getRiskLevel(riskScore),
                confidence: customContext.confidence || 0.8
            };
            
            // Add mitigation guidance if requested
            if (includeGuidance) {
                educationalContent.guidance = this.templates.mitigationGuidance[hazardType] || [];
                educationalContent.priorityActions = this._prioritizeMitigationActions(
                    hazardType, 
                    riskScore, 
                    customContext
                );
            }
            
            // Add data source information if requested
            if (includeSources) {
                educationalContent.dataSources = {
                    description: hazardData.sources,
                    methodology: this.templates.methodologyExplanations.dataCollection,
                    qualityInfo: this._generateQualityExplanation(customContext.dataQuality)
                };
            }
            
            // Add readability metrics
            educationalContent.readability = this._calculateReadability(educationalContent.explanation);
            
            this.emit('educationalContentGenerated', {
                hazardType,
                riskScore,
                contentLength: educationalContent.explanation.length,
                readabilityScore: educationalContent.readability.gradeLevel
            });
            
            return educationalContent;
            
        } catch (error) {
            this.emit('contentGenerationError', {
                hazardType,
                error: error.message
            });
            throw error;
        }
    }

    /**
     * Generate methodology explanation for transparency
     */
    async generateMethodologyExplanation(riskAssessmentData, options = {}) {
        const {
            includeDataSources = true,
            includeQualityMetrics = true,
            includeUncertainty = true
        } = options;
        
        const methodology = {
            overview: this.templates.methodologyExplanations.riskCalculation,
            steps: []
        };
        
        // Explain data collection step
        if (includeDataSources && riskAssessmentData.sources) {
            methodology.steps.push({
                step: "Data Collection",
                description: this.templates.methodologyExplanations.dataCollection,
                sources: riskAssessmentData.sources.map(source => ({
                    name: this._formatSourceName(source),
                    description: this._getSourceDescription(source),
                    authority: this._getSourceAuthority(source)
                }))
            });
        }
        
        // Explain quality assurance step
        if (includeQualityMetrics && riskAssessmentData.dataQuality) {
            methodology.steps.push({
                step: "Quality Assurance",
                description: this.templates.methodologyExplanations.qualityAssurance,
                metrics: {
                    freshness: {
                        score: riskAssessmentData.dataQuality.freshness,
                        explanation: "How recently the data was updated"
                    },
                    completeness: {
                        score: riskAssessmentData.dataQuality.completeness,
                        explanation: "What percentage of expected data points are available"
                    },
                    accuracy: {
                        score: riskAssessmentData.dataQuality.accuracy,
                        explanation: "Statistical validation of data values"
                    },
                    consistency: {
                        score: riskAssessmentData.dataQuality.consistency,
                        explanation: "Agreement between different data sources"
                    }
                }
            });
        }
        
        // Explain uncertainty and confidence
        if (includeUncertainty) {
            methodology.steps.push({
                step: "Uncertainty Assessment",
                description: this.templates.methodologyExplanations.uncertainty,
                confidenceLevels: this._explainConfidenceLevels()
            });
        }
        
        return methodology;
    }

    /**
     * Generate risk comparison explanation
     */
    async generateComparisonExplanation(properties, comparisonType = 'relative') {
        const comparisons = properties.map((property, index) => ({
            rank: index + 1,
            location: property.location,
            overallRisk: property.overallRisk,
            topHazards: this._getTopHazards(property.hazardRisks, 3)
        }));
        
        const explanation = {
            comparisonType,
            summary: this._generateComparisonSummary(comparisons),
            insights: this._generateComparisonInsights(comparisons),
            methodology: "Properties are ranked by overall risk score, which combines individual hazard risks weighted by their potential impact and likelihood."
        };
        
        return explanation;
    }

    /**
     * Optimize content for target reading level
     */
    _optimizeReadability(text) {
        const target = this.readabilityTargets[this.config.readingLevel];
        if (!target) return text;
        
        // Split into sentences and optimize each
        const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
        
        const optimizedSentences = sentences.map(sentence => {
            const words = sentence.trim().split(/\\s+/);
            
            // Break up long sentences
            if (words.length > target.maxWordsPerSentence) {
                return this._breakLongSentence(sentence, target.maxWordsPerSentence);
            }
            
            // Simplify complex words
            return this._simplifyComplexWords(sentence, target.maxSyllablesPerWord);
        });
        
        return optimizedSentences.join('. ') + '.';
    }

    /**
     * Calculate readability metrics
     */
    _calculateReadability(text) {
        const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
        const words = text.split(/\\s+/).filter(w => w.length > 0);
        const syllables = words.reduce((count, word) => count + this._countSyllables(word), 0);
        
        // Flesch-Kincaid Grade Level formula
        const avgSentenceLength = words.length / sentences.length;
        const avgSyllablesPerWord = syllables / words.length;
        const gradeLevel = 0.39 * avgSentenceLength + 11.8 * avgSyllablesPerWord - 15.59;
        
        return {
            gradeLevel: Math.max(1, Math.round(gradeLevel)),
            wordCount: words.length,
            sentenceCount: sentences.length,
            avgWordsPerSentence: Math.round(avgSentenceLength),
            avgSyllablesPerWord: Math.round(avgSyllablesPerWord * 10) / 10
        };
    }

    // Helper methods for educational content generation
    _getRiskLevelContext(riskScore) {
        if (riskScore >= 80) return "This represents an extreme risk level that requires immediate attention and mitigation planning.";
        if (riskScore >= 60) return "This is a very high risk level that warrants serious consideration and protective measures.";
        if (riskScore >= 40) return "This indicates a high risk level where preventive actions would be beneficial.";
        if (riskScore >= 20) return "This shows a moderate risk level that should be monitored and addressed over time.";
        return "This represents a low risk level, but basic preparedness is still recommended.";
    }

    _getRiskLevel(riskScore) {
        if (riskScore >= 80) return 'EXTREME';
        if (riskScore >= 60) return 'VERY_HIGH';
        if (riskScore >= 40) return 'HIGH';
        if (riskScore >= 20) return 'MODERATE';
        return 'LOW';
    }

    _addLocationContext(explanation, hazardType, location) {
        // Add location-specific context based on geographic features
        // This would integrate with geographic data in a real implementation
        return explanation + \` This assessment is specific to your location at \${location.address || 'the specified coordinates'}.\`;
    }

    _prioritizeMitigationActions(hazardType, riskScore, context) {
        const allActions = this.templates.mitigationGuidance[hazardType] || [];
        
        // Prioritize based on risk score and effectiveness
        return allActions.slice(0, Math.min(3, Math.ceil(riskScore / 25)));
    }

    _generateQualityExplanation(dataQuality) {
        if (!dataQuality) return "Data quality metrics are not available for this assessment.";
        
        const overall = Math.round(dataQuality.overall * 100);
        
        if (overall >= 90) return \`Data quality is excellent (\${overall}%) with recent, complete, and accurate information.\`;
        if (overall >= 75) return \`Data quality is good (\${overall}%) with reliable information from authoritative sources.\`;
        if (overall >= 60) return \`Data quality is fair (\${overall}%) - some limitations in data freshness or completeness may affect precision.\`;
        return \`Data quality is limited (\${overall}%) - results should be interpreted with caution due to data constraints.\`;
    }

    _formatSourceName(source) {
        const sourceNames = {
            'fema': 'Federal Emergency Management Agency (FEMA)',
            'noaa': 'National Oceanic and Atmospheric Administration (NOAA)',
            'usgs': 'U.S. Geological Survey (USGS)',
            'epa': 'Environmental Protection Agency (EPA)'
        };
        return sourceNames[source.toLowerCase()] || source;
    }

    _getSourceDescription(source) {
        const descriptions = {
            'fema': 'Federal agency responsible for disaster preparedness and response',
            'noaa': 'Federal agency providing weather, climate, and oceanographic data',
            'usgs': 'Federal agency providing geological and natural hazard information',
            'epa': 'Federal agency monitoring environmental health and safety'
        };
        return descriptions[source.toLowerCase()] || 'Government data source';
    }

    _getSourceAuthority(source) {
        return 'U.S. Federal Government';
    }

    _explainConfidenceLevels() {
        return {
            high: "High confidence (80-100%): Multiple reliable data sources agree, recent data available",
            medium: "Medium confidence (60-79%): Good data available but some limitations in coverage or recency", 
            low: "Low confidence (40-59%): Limited data available, older information, or conflicting sources",
            veryLow: "Very low confidence (<40%): Insufficient or unreliable data, estimates only"
        };
    }

    _generateComparisonSummary(comparisons) {
        const highest = comparisons[0];
        const lowest = comparisons[comparisons.length - 1];
        
        return \`Among the compared properties, \${highest.location.address || 'Property 1'} has the highest overall risk (\${highest.overallRisk}), while \${lowest.location.address || \`Property \${lowest.rank}\`} has the lowest risk (\${lowest.overallRisk}).\`;
    }

    _generateComparisonInsights(comparisons) {
        // Analyze patterns in the comparison data
        const insights = [];
        
        // Find common high-risk hazards
        const hazardCounts = {};
        comparisons.forEach(comp => {
            comp.topHazards.forEach(hazard => {
                hazardCounts[hazard] = (hazardCounts[hazard] || 0) + 1;
            });
        });
        
        const mostCommonHazard = Object.keys(hazardCounts).reduce((a, b) => 
            hazardCounts[a] > hazardCounts[b] ? a : b
        );
        
        insights.push(\`\${mostCommonHazard} risk appears to be elevated across multiple properties in this comparison.\`);
        
        return insights;
    }

    _getTopHazards(hazardRisks, count = 3) {
        return Object.entries(hazardRisks)
            .sort(([,a], [,b]) => (b.adjustedScore || b.score) - (a.adjustedScore || a.score))
            .slice(0, count)
            .map(([hazard]) => hazard);
    }

    _breakLongSentence(sentence, maxWords) {
        // Simple sentence breaking at conjunction points
        const conjunctions = [' and ', ' but ', ' or ', ' so ', ' because ', ' although ', ' while '];
        
        for (const conjunction of conjunctions) {
            if (sentence.includes(conjunction)) {
                const parts = sentence.split(conjunction);
                if (parts.length === 2 && parts[0].split(' ').length > maxWords / 2) {
                    return parts[0].trim() + '. ' + parts[1].trim();
                }
            }
        }
        
        return sentence; // Return original if no good breaking point found
    }

    _simplifyComplexWords(sentence, maxAvgSyllables) {
        // Word simplification mapping
        const simplifications = {
            'approximately': 'about',
            'demonstrate': 'show',
            'facilitate': 'help',
            'implement': 'use',
            'significant': 'large',
            'indicates': 'shows',
            'assessment': 'review',
            'consideration': 'thought'
        };
        
        let result = sentence;
        for (const [complex, simple] of Object.entries(simplifications)) {
            result = result.replace(new RegExp(complex, 'gi'), simple);
        }
        
        return result;
    }

    _countSyllables(word) {
        // Simple syllable counting heuristic
        word = word.toLowerCase();
        if (word.length <= 3) return 1;
        
        const vowels = word.match(/[aeiouy]+/g);
        let syllableCount = vowels ? vowels.length : 1;
        
        // Adjust for silent 'e'
        if (word.endsWith('e')) syllableCount--;
        
        return Math.max(1, syllableCount);
    }
}

module.exports = ${agentName};
`;

        const outputPath = this.outputDir + `/handlers/${agentName}.js`;
        require('fs').writeFileSync(outputPath, educationAgentCode);
        
        console.log(`🎓 Generated Climate Education Agent: ${outputPath}`);
        return outputPath;
    }
}

module.exports = ClimateVisualizationAgent;