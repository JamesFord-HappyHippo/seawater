/**
 * Climate Data Processing Agent Template
 * Generated by Agent Factory for Seawater Platform
 * 
 * This template generates specialized agents for processing government climate data
 * with automated quality assurance, caching, and cross-source validation.
 */

const AgentFactory = require('../AgentFactory');

class ClimateDataProcessingAgent extends AgentFactory {
    constructor() {
        super();
        this.domain = 'climate-data-processing';
        
        // Climate-specific patterns
        this.climatePatterns = {
            dataSourceTypes: ['FEMA_NRI', 'NOAA_CDO', 'USGS_Earthquake', 'EPA_AQS'],
            hazardTypes: ['flood', 'wildfire', 'hurricane', 'earthquake', 'heat', 'drought', 'tornado', 'hail'],
            qualityMetrics: ['freshness', 'completeness', 'accuracy', 'consistency'],
            spatialResolution: ['property', 'census_tract', 'county', 'state'],
            temporalResolution: ['realtime', 'daily', 'monthly', 'annual', 'historical']
        };

        // Government API rate limits and caching strategies
        this.apiConstraints = {
            FEMA: { rateLimit: '1000/hour', cacheTTL: '1hour' },
            NOAA: { rateLimit: '10000/day', cacheTTL: '12hours' },
            USGS: { rateLimit: 'unlimited', cacheTTL: '5minutes' },
            EPA: { rateLimit: '1000/hour', cacheTTL: '6hours' }
        };
    }

    /**
     * Generate multi-source data collector agent
     */
    generateMultiSourceCollector(config) {
        const {
            agentName,
            dataSources,
            hazardTypes,
            cacheStrategy = 'intelligent',
            qualityThreshold = 0.85
        } = config;

        const collectorCode = `/**
 * ${agentName} - Multi-source government climate data collector
 * Generated by Agent Factory for optimized data aggregation
 * 
 * Features:
 * - Parallel API calls with intelligent queuing
 * - Automated quality scoring and validation
 * - Cross-source data consistency checking
 * - Intelligent caching with TTL optimization
 */

const { EventEmitter } = require('events');
const { FEMAClient } = require('../../backend/src/integrations/clients/government/FEMAClient');
const { USGSClient } = require('../../backend/src/integrations/clients/government/USGSClient');
const { NoaaDataClient } = require('../../helpers/externalClients/noaaDataClient');
const { CacheManager } = require('../../backend/src/integrations/core/CacheManager');
const { DataSourceManager } = require('../../backend/src/integrations/core/DataSourceManager');

class ${agentName} extends EventEmitter {
    constructor(options = {}) {
        super();
        
        // Initialize data source clients
        this.clients = {
            fema: new FEMAClient({
                httpClient: options.httpClient,
                cacheManager: options.cacheManager
            }),
            noaa: new NoaaDataClient({
                apiToken: process.env.NOAA_API_TOKEN,
                timeout: 30000
            }),
            usgs: new USGSClient({
                httpClient: options.httpClient,
                cacheManager: options.cacheManager
            })
        };
        
        this.cacheManager = options.cacheManager || new CacheManager();
        this.dataSourceManager = new DataSourceManager();
        
        // Configuration
        this.config = {
            qualityThreshold: ${qualityThreshold},
            maxRetries: 3,
            timeoutMs: 30000,
            parallelRequests: true,
            cacheStrategy: '${cacheStrategy}'
        };
        
        // Statistics tracking
        this.stats = {
            totalRequests: 0,
            successfulRequests: 0,
            cacheHits: 0,
            qualityScores: [],
            averageResponseTime: 0
        };
        
        // Hazard types this agent handles
        this.hazardTypes = ${JSON.stringify(hazardTypes)};
        
        // Data source reliability weights
        this.sourceWeights = {
            fema: 0.4,  // Authoritative for risk scores
            noaa: 0.35, // Excellent for historical climate
            usgs: 0.25  // Authoritative for earthquakes
        };
    }

    /**
     * Collect comprehensive risk data for a location
     */
    async collectLocationRiskData(latitude, longitude, options = {}) {
        const requestId = this._generateRequestId();
        const startTime = Date.now();
        
        try {
            console.log(\`[\${requestId}] Starting multi-source data collection for \${latitude}, \${longitude}\`);
            
            // Build cache key for location-based data
            const cacheKey = \`location_risk_\${latitude}_\${longitude}_\${JSON.stringify(options)}\`;
            
            // Check cache first
            const cachedData = await this._checkCache(cacheKey);
            if (cachedData) {
                this.stats.cacheHits++;
                this.emit('cacheHit', { requestId, cacheKey });
                return cachedData;
            }
            
            // Collect data from all sources in parallel
            const dataCollectionPromises = [];
            
            ${dataSources.includes('FEMA') ? `
            // FEMA National Risk Index data
            dataCollectionPromises.push(
                this.clients.fema.getRiskByCoordinates(latitude, longitude, {
                    hazardTypes: this.hazardTypes
                }).then(data => ({ source: 'fema', data, weight: this.sourceWeights.fema }))
                .catch(error => ({ source: 'fema', error: error.message, weight: 0 }))
            );
            ` : ''}
            
            ${dataSources.includes('NOAA') ? `
            // NOAA Historical Climate Extremes
            dataCollectionPromises.push(
                this.clients.noaa.getHistoricalExtremes(latitude, longitude, 30)
                .then(response => ({ source: 'noaa', data: response.data, weight: this.sourceWeights.noaa }))
                .catch(error => ({ source: 'noaa', error: error.message, weight: 0 }))
            );
            ` : ''}
            
            ${dataSources.includes('USGS') ? `
            // USGS Earthquake Risk Assessment
            dataCollectionPromises.push(
                this.clients.usgs.getEarthquakeRisk(latitude, longitude, { radiusKm: 50 })
                .then(data => ({ source: 'usgs', data, weight: this.sourceWeights.usgs }))
                .catch(error => ({ source: 'usgs', error: error.message, weight: 0 }))
            );
            ` : ''}
            
            // Wait for all data collection to complete
            const sourceResults = await Promise.allSettled(dataCollectionPromises);
            const successfulResults = sourceResults
                .filter(result => result.status === 'fulfilled' && !result.value.error)
                .map(result => result.value);
                
            if (successfulResults.length === 0) {
                throw new Error('No data sources returned valid data');
            }
            
            // Process and validate collected data
            const processedData = await this._processCollectedData(successfulResults, latitude, longitude);
            const qualityScore = await this._calculateDataQuality(processedData);
            
            if (qualityScore < this.config.qualityThreshold) {
                console.warn(\`[\${requestId}] Data quality below threshold: \${qualityScore}\`);
                this.emit('lowQuality', { requestId, qualityScore, threshold: this.config.qualityThreshold });
            }
            
            // Enhance with cross-source validation
            const validatedData = await this._crossValidateData(processedData);
            
            // Add metadata
            const finalData = {
                ...validatedData,
                metadata: {
                    requestId,
                    location: { latitude, longitude },
                    sources: successfulResults.map(r => r.source),
                    qualityScore,
                    collectedAt: new Date().toISOString(),
                    responseTimeMs: Date.now() - startTime,
                    cacheStrategy: this.config.cacheStrategy
                }
            };
            
            // Cache the processed data
            await this._cacheResult(cacheKey, finalData, qualityScore);
            
            // Update statistics
            this._updateStats(true, Date.now() - startTime, qualityScore);
            
            this.emit('dataCollected', {
                requestId,
                location: { latitude, longitude },
                sources: finalData.metadata.sources,
                qualityScore,
                responseTime: Date.now() - startTime
            });
            
            return finalData;
            
        } catch (error) {
            this._updateStats(false, Date.now() - startTime);
            
            this.emit('collectionError', {
                requestId,
                error: error.message,
                location: { latitude, longitude }
            });
            
            throw new Error(\`Multi-source data collection failed: \${error.message}\`);
        }
    }

    /**
     * Process collected data from multiple sources
     */
    async _processCollectedData(sourceResults, latitude, longitude) {
        const processedData = {
            location: { latitude, longitude },
            riskScores: {},
            dataQuality: {},
            sourceContributions: {}
        };
        
        // Process each hazard type across all sources
        for (const hazardType of this.hazardTypes) {
            const hazardData = [];
            
            // Extract hazard-specific data from each source
            sourceResults.forEach(result => {
                const sourceHazardData = this._extractHazardData(result, hazardType);
                if (sourceHazardData && sourceHazardData.score !== null) {
                    hazardData.push({
                        source: result.source,
                        score: sourceHazardData.score,
                        confidence: sourceHazardData.confidence || 0.8,
                        weight: result.weight
                    });
                }
            });
            
            if (hazardData.length > 0) {
                // Calculate weighted average score
                const weightedSum = hazardData.reduce((sum, data) => sum + (data.score * data.weight * data.confidence), 0);
                const totalWeight = hazardData.reduce((sum, data) => sum + (data.weight * data.confidence), 0);
                
                processedData.riskScores[hazardType] = {
                    aggregatedScore: Math.round(weightedSum / totalWeight),
                    sources: hazardData,
                    confidence: this._calculateAggregateConfidence(hazardData),
                    lastUpdated: new Date().toISOString()
                };
            }
        }
        
        return processedData;
    }

    /**
     * Extract hazard-specific data from source result
     */
    _extractHazardData(result, hazardType) {
        if (result.error) return null;
        
        switch (result.source) {
            case 'fema':
                return this._extractFEMAHazardData(result.data, hazardType);
            case 'noaa':
                return this._extractNOAAHazardData(result.data, hazardType);
            case 'usgs':
                return this._extractUSGSHazardData(result.data, hazardType);
            default:
                return null;
        }
    }

    /**
     * Cross-validate data between sources
     */
    async _crossValidateData(processedData) {
        const validationResults = {};
        
        // Validate each hazard type across sources
        for (const [hazardType, hazardData] of Object.entries(processedData.riskScores)) {
            if (hazardData.sources.length > 1) {
                const scores = hazardData.sources.map(s => s.score);
                const standardDeviation = this._calculateStandardDeviation(scores);
                const coefficient = standardDeviation / (scores.reduce((a, b) => a + b, 0) / scores.length);
                
                validationResults[hazardType] = {
                    agreement: coefficient < 0.3 ? 'high' : coefficient < 0.6 ? 'medium' : 'low',
                    coefficient,
                    standardDeviation,
                    sourceCount: hazardData.sources.length
                };
            }
        }
        
        return {
            ...processedData,
            crossValidation: validationResults
        };
    }

    /**
     * Calculate overall data quality score
     */
    async _calculateDataQuality(processedData) {
        let totalQuality = 0;
        let qualityFactors = 0;
        
        // Freshness score (based on when data was last updated)
        const freshnessScore = this._calculateFreshnessScore(processedData);
        totalQuality += freshnessScore * 0.25;
        qualityFactors += 0.25;
        
        // Completeness score (how many hazards have data)
        const completenessScore = Object.keys(processedData.riskScores).length / this.hazardTypes.length;
        totalQuality += completenessScore * 0.25;
        qualityFactors += 0.25;
        
        // Source diversity score (how many different sources contributed)
        const allSources = new Set();
        Object.values(processedData.riskScores).forEach(hazard => {
            hazard.sources.forEach(source => allSources.add(source.source));
        });
        const diversityScore = allSources.size / Object.keys(this.clients).length;
        totalQuality += diversityScore * 0.25;
        qualityFactors += 0.25;
        
        // Confidence score (average confidence across all data points)
        const confidenceScores = Object.values(processedData.riskScores).map(h => h.confidence);
        const avgConfidence = confidenceScores.reduce((a, b) => a + b, 0) / confidenceScores.length;
        totalQuality += (avgConfidence || 0) * 0.25;
        qualityFactors += 0.25;
        
        return totalQuality / qualityFactors;
    }

    /**
     * Cache result with intelligent TTL based on data quality
     */
    async _cacheResult(cacheKey, data, qualityScore) {
        // Higher quality data gets cached longer
        const baseTTL = 3600; // 1 hour
        const qualityMultiplier = Math.max(0.5, qualityScore);
        const ttl = Math.round(baseTTL * qualityMultiplier);
        
        await this.cacheManager.set(cacheKey, data, { ttl });
    }

    // Additional helper methods...
    _generateRequestId() {
        return \`msc_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
    }

    _updateStats(success, responseTime, qualityScore) {
        this.stats.totalRequests++;
        if (success) this.stats.successfulRequests++;
        if (qualityScore) this.stats.qualityScores.push(qualityScore);
        
        // Update average response time
        if (this.stats.totalRequests === 1) {
            this.stats.averageResponseTime = responseTime;
        } else {
            this.stats.averageResponseTime = 
                this.stats.averageResponseTime * 0.9 + responseTime * 0.1;
        }
    }

    _calculateStandardDeviation(values) {
        const mean = values.reduce((a, b) => a + b, 0) / values.length;
        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
        return Math.sqrt(variance);
    }

    _calculateFreshnessScore(processedData) {
        // Implementation for freshness calculation based on data timestamps
        return 0.9; // Placeholder
    }

    _calculateAggregateConfidence(hazardData) {
        const weightedConfidence = hazardData.reduce((sum, data) => 
            sum + (data.confidence * data.weight), 0);
        const totalWeight = hazardData.reduce((sum, data) => sum + data.weight, 0);
        return weightedConfidence / totalWeight;
    }

    async _checkCache(cacheKey) {
        try {
            return await this.cacheManager.get(cacheKey);
        } catch (error) {
            console.warn('Cache lookup failed:', error.message);
            return null;
        }
    }

    // Source-specific data extraction methods
    _extractFEMAHazardData(femaData, hazardType) {
        // Implementation for extracting specific hazard data from FEMA response
        return null; // Placeholder
    }

    _extractNOAAHazardData(noaaData, hazardType) {
        // Implementation for extracting specific hazard data from NOAA response
        return null; // Placeholder
    }

    _extractUSGSHazardData(usgsData, hazardType) {
        // Implementation for extracting specific hazard data from USGS response
        return null; // Placeholder
    }

    /**
     * Get agent statistics and performance metrics
     */
    getStats() {
        const successRate = this.stats.totalRequests > 0 
            ? Math.round((this.stats.successfulRequests / this.stats.totalRequests) * 100) 
            : 0;
            
        const avgQuality = this.stats.qualityScores.length > 0
            ? this.stats.qualityScores.reduce((a, b) => a + b, 0) / this.stats.qualityScores.length
            : 0;

        return {
            ...this.stats,
            successRate,
            averageQuality: Math.round(avgQuality * 100),
            cacheHitRate: this.stats.totalRequests > 0 
                ? Math.round((this.stats.cacheHits / this.stats.totalRequests) * 100) 
                : 0
        };
    }
}

module.exports = ${agentName};
`;

        const outputPath = this.outputDir + `/handlers/${agentName}.js`;
        require('fs').writeFileSync(outputPath, collectorCode);
        
        console.log(`üåä Generated Climate Data Collector Agent: ${outputPath}`);
        return outputPath;
    }

    /**
     * Generate data quality assurance agent
     */
    generateDataQualityAgent(config) {
        const {
            agentName = 'DataQualityAssuranceAgent',
            qualityThresholds = {
                freshness: 0.8,
                completeness: 0.9,
                accuracy: 0.85,
                consistency: 0.8
            },
            alertingEnabled = true
        } = config;

        const qaAgentCode = `/**
 * ${agentName} - Automated data quality assessment for government climate data
 * Generated by Agent Factory for comprehensive quality monitoring
 */

const { EventEmitter } = require('events');

class ${agentName} extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.thresholds = ${JSON.stringify(qualityThresholds, null, 8)};
        this.alertingEnabled = ${alertingEnabled};
        
        // Quality assessment algorithms
        this.assessmentMethods = {
            freshness: this._assessDataFreshness.bind(this),
            completeness: this._assessDataCompleteness.bind(this),
            accuracy: this._assessDataAccuracy.bind(this),
            consistency: this._assessDataConsistency.bind(this)
        };
        
        // Statistical methods for quality analysis
        this.statisticalMethods = {
            zScore: this._calculateZScore.bind(this),
            iqrOutliers: this._detectIQROutliers.bind(this),
            temporalAnomalies: this._detectTemporalAnomalies.bind(this)
        };
        
        // Quality history for trend analysis
        this.qualityHistory = [];
        this.maxHistoryLength = 1000;
    }

    /**
     * Perform comprehensive quality assessment
     */
    async assessDataQuality(data, metadata = {}) {
        const assessment = {
            overall: 0,
            dimensions: {},
            issues: [],
            recommendations: [],
            timestamp: new Date().toISOString(),
            metadata
        };

        // Assess each quality dimension
        for (const [dimension, assessmentMethod] of Object.entries(this.assessmentMethods)) {
            try {
                const dimensionScore = await assessmentMethod(data, metadata);
                assessment.dimensions[dimension] = {
                    score: dimensionScore.score,
                    details: dimensionScore.details,
                    threshold: this.thresholds[dimension],
                    passed: dimensionScore.score >= this.thresholds[dimension]
                };

                if (!assessment.dimensions[dimension].passed) {
                    assessment.issues.push({
                        dimension,
                        score: dimensionScore.score,
                        threshold: this.thresholds[dimension],
                        severity: this._calculateSeverity(dimensionScore.score, this.thresholds[dimension]),
                        details: dimensionScore.details
                    });
                }
            } catch (error) {
                assessment.dimensions[dimension] = {
                    error: error.message,
                    passed: false
                };
                assessment.issues.push({
                    dimension,
                    error: error.message,
                    severity: 'high'
                });
            }
        }

        // Calculate overall quality score
        const validScores = Object.values(assessment.dimensions)
            .filter(d => !d.error && typeof d.score === 'number')
            .map(d => d.score);
            
        assessment.overall = validScores.length > 0 
            ? validScores.reduce((sum, score) => sum + score, 0) / validScores.length
            : 0;

        // Generate recommendations
        assessment.recommendations = this._generateRecommendations(assessment);

        // Store in quality history
        this._updateQualityHistory(assessment);

        // Emit alerts if needed
        if (this.alertingEnabled) {
            this._checkAndEmitAlerts(assessment);
        }

        return assessment;
    }

    /**
     * Assess data freshness
     */
    async _assessDataFreshness(data, metadata) {
        const now = Date.now();
        const timestamps = [];
        
        // Extract all timestamps from data
        this._extractTimestamps(data, timestamps);
        
        if (timestamps.length === 0) {
            return {
                score: 0,
                details: 'No timestamps found in data'
            };
        }

        // Calculate freshness metrics
        const mostRecent = Math.max(...timestamps);
        const oldest = Math.min(...timestamps);
        const averageAge = (now - (timestamps.reduce((sum, ts) => sum + ts, 0) / timestamps.length)) / (1000 * 60 * 60); // hours
        
        // Score based on average age (fresher = higher score)
        const maxAcceptableAgeHours = 24;
        const freshnessScore = Math.max(0, Math.min(1, 1 - (averageAge / maxAcceptableAgeHours)));
        
        return {
            score: freshnessScore,
            details: {
                averageAgeHours: Math.round(averageAge * 100) / 100,
                mostRecentAgeHours: Math.round((now - mostRecent) / (1000 * 60 * 60) * 100) / 100,
                oldestAgeHours: Math.round((now - oldest) / (1000 * 60 * 60) * 100) / 100,
                timestampCount: timestamps.length
            }
        };
    }

    /**
     * Assess data completeness
     */
    async _assessDataCompleteness(data, metadata) {
        const expectedFields = this._getExpectedFields(data, metadata);
        const actualFields = this._getActualFields(data);
        
        const missing = expectedFields.filter(field => !actualFields.includes(field));
        const completenessRatio = (expectedFields.length - missing.length) / expectedFields.length;
        
        return {
            score: completenessRatio,
            details: {
                expectedFieldCount: expectedFields.length,
                actualFieldCount: actualFields.length,
                missingFields: missing,
                completenessPercentage: Math.round(completenessRatio * 100)
            }
        };
    }

    /**
     * Assess data accuracy using statistical methods
     */
    async _assessDataAccuracy(data, metadata) {
        const accuracyMetrics = {
            outlierCount: 0,
            totalDataPoints: 0,
            anomalies: [],
            statisticalSummary: {}
        };

        // Extract numeric values for statistical analysis
        const numericValues = this._extractNumericValues(data);
        
        if (numericValues.length === 0) {
            return {
                score: 1,
                details: 'No numeric values found for accuracy assessment'
            };
        }

        accuracyMetrics.totalDataPoints = numericValues.length;

        // Detect outliers using IQR method
        const iqrOutliers = this.statisticalMethods.iqrOutliers(numericValues);
        accuracyMetrics.outlierCount += iqrOutliers.length;
        accuracyMetrics.anomalies.push(...iqrOutliers.map(o => ({ type: 'iqr_outlier', value: o })));

        // Detect outliers using Z-score method
        const zScoreOutliers = numericValues.filter(val => Math.abs(this.statisticalMethods.zScore(val, numericValues)) > 3);
        accuracyMetrics.anomalies.push(...zScoreOutliers.map(o => ({ type: 'zscore_outlier', value: o })));

        // Calculate accuracy score (inverse of outlier ratio)
        const outlierRatio = accuracyMetrics.outlierCount / accuracyMetrics.totalDataPoints;
        const accuracyScore = Math.max(0, 1 - (outlierRatio * 2)); // Penalize outliers

        accuracyMetrics.statisticalSummary = {
            mean: numericValues.reduce((sum, val) => sum + val, 0) / numericValues.length,
            median: this._calculateMedian(numericValues),
            standardDeviation: this._calculateStandardDeviation(numericValues),
            outlierRatio
        };

        return {
            score: accuracyScore,
            details: accuracyMetrics
        };
    }

    /**
     * Assess data consistency across sources and time
     */
    async _assessDataConsistency(data, metadata) {
        const consistencyMetrics = {
            crossSourceAgreement: 1,
            temporalConsistency: 1,
            formatConsistency: 1,
            valueRangeConsistency: 1
        };

        // Check cross-source consistency if multiple sources present
        if (data.sources && data.sources.length > 1) {
            consistencyMetrics.crossSourceAgreement = this._assessCrossSourceConsistency(data);
        }

        // Check temporal consistency for time series data
        const temporalData = this._extractTemporalData(data);
        if (temporalData.length > 1) {
            consistencyMetrics.temporalConsistency = this._assessTemporalConsistency(temporalData);
        }

        // Check format consistency
        consistencyMetrics.formatConsistency = this._assessFormatConsistency(data);

        // Check value range consistency
        consistencyMetrics.valueRangeConsistency = this._assessValueRangeConsistency(data);

        // Calculate overall consistency score
        const consistencyScore = Object.values(consistencyMetrics).reduce((sum, score) => sum + score, 0) / Object.keys(consistencyMetrics).length;

        return {
            score: consistencyScore,
            details: consistencyMetrics
        };
    }

    // Helper methods for quality assessment
    _extractTimestamps(obj, timestamps, path = '') {
        if (obj === null || obj === undefined) return;
        
        if (typeof obj === 'object') {
            for (const [key, value] of Object.entries(obj)) {
                if (key.toLowerCase().includes('time') || key.toLowerCase().includes('date') || key === 'timestamp') {
                    const timestamp = new Date(value).getTime();
                    if (!isNaN(timestamp)) {
                        timestamps.push(timestamp);
                    }
                } else if (typeof value === 'object') {
                    this._extractTimestamps(value, timestamps, \`\${path}.\${key}\`);
                }
            }
        }
    }

    _getExpectedFields(data, metadata) {
        // Define expected fields based on data type and source
        const baseFields = ['location', 'timestamp', 'source'];
        
        if (metadata.sources && metadata.sources.includes('fema')) {
            baseFields.push('riskScores', 'hazardTypes');
        }
        if (metadata.sources && metadata.sources.includes('noaa')) {
            baseFields.push('temperature', 'precipitation');
        }
        if (metadata.sources && metadata.sources.includes('usgs')) {
            baseFields.push('magnitude', 'seismicActivity');
        }
        
        return baseFields;
    }

    _getActualFields(obj, fields = new Set(), path = '') {
        if (obj === null || obj === undefined) return Array.from(fields);
        
        if (typeof obj === 'object') {
            for (const key of Object.keys(obj)) {
                fields.add(key);
                if (typeof obj[key] === 'object') {
                    this._getActualFields(obj[key], fields, \`\${path}.\${key}\`);
                }
            }
        }
        
        return Array.from(fields);
    }

    _extractNumericValues(obj, values = []) {
        if (obj === null || obj === undefined) return values;
        
        if (typeof obj === 'number' && !isNaN(obj)) {
            values.push(obj);
        } else if (typeof obj === 'object') {
            for (const value of Object.values(obj)) {
                this._extractNumericValues(value, values);
            }
        }
        
        return values;
    }

    _calculateZScore(value, dataset) {
        const mean = dataset.reduce((sum, val) => sum + val, 0) / dataset.length;
        const stdDev = this._calculateStandardDeviation(dataset);
        return stdDev === 0 ? 0 : (value - mean) / stdDev;
    }

    _detectIQROutliers(values) {
        const sorted = [...values].sort((a, b) => a - b);
        const q1Index = Math.floor(sorted.length * 0.25);
        const q3Index = Math.floor(sorted.length * 0.75);
        const q1 = sorted[q1Index];
        const q3 = sorted[q3Index];
        const iqr = q3 - q1;
        const lowerBound = q1 - 1.5 * iqr;
        const upperBound = q3 + 1.5 * iqr;
        
        return values.filter(val => val < lowerBound || val > upperBound);
    }

    _calculateMedian(values) {
        const sorted = [...values].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
    }

    _calculateStandardDeviation(values) {
        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
        return Math.sqrt(variance);
    }

    _calculateSeverity(score, threshold) {
        const gap = threshold - score;
        if (gap <= 0) return 'none';
        if (gap <= 0.1) return 'low';
        if (gap <= 0.3) return 'medium';
        return 'high';
    }

    _generateRecommendations(assessment) {
        const recommendations = [];
        
        assessment.issues.forEach(issue => {
            switch (issue.dimension) {
                case 'freshness':
                    recommendations.push(\`Update data sources more frequently. Current average age: \${issue.details?.averageAgeHours}h\`);
                    break;
                case 'completeness':
                    recommendations.push(\`Add missing data fields: \${issue.details?.missingFields?.join(', ')}\`);
                    break;
                case 'accuracy':
                    recommendations.push(\`Investigate \${issue.details?.outlierCount} outlier values detected in the dataset\`);
                    break;
                case 'consistency':
                    recommendations.push('Review data validation rules and cross-source agreement protocols');
                    break;
            }
        });
        
        return recommendations;
    }

    _updateQualityHistory(assessment) {
        this.qualityHistory.push({
            timestamp: assessment.timestamp,
            overall: assessment.overall,
            dimensions: Object.fromEntries(
                Object.entries(assessment.dimensions).map(([dim, data]) => [dim, data.score])
            )
        });

        if (this.qualityHistory.length > this.maxHistoryLength) {
            this.qualityHistory = this.qualityHistory.slice(-this.maxHistoryLength);
        }
    }

    _checkAndEmitAlerts(assessment) {
        const criticalIssues = assessment.issues.filter(issue => issue.severity === 'high');
        
        if (criticalIssues.length > 0) {
            this.emit('criticalQualityAlert', {
                assessment,
                criticalIssues,
                timestamp: new Date().toISOString()
            });
        }
        
        if (assessment.overall < 0.7) {
            this.emit('lowQualityAlert', {
                overallScore: assessment.overall,
                assessment,
                timestamp: new Date().toISOString()
            });
        }
    }

    // Placeholder methods for consistency assessment
    _assessCrossSourceConsistency(data) { return 0.9; }
    _assessTemporalConsistency(temporalData) { return 0.9; }
    _assessFormatConsistency(data) { return 0.95; }
    _assessValueRangeConsistency(data) { return 0.9; }
    _extractTemporalData(data) { return []; }
    _detectTemporalAnomalies(data) { return []; }

    /**
     * Get quality trends and statistics
     */
    getQualityTrends() {
        if (this.qualityHistory.length === 0) return null;
        
        const recent = this.qualityHistory.slice(-10);
        const overall = recent.map(h => h.overall);
        
        return {
            currentQuality: recent[recent.length - 1].overall,
            averageQuality: overall.reduce((sum, q) => sum + q, 0) / overall.length,
            trend: overall.length > 1 ? overall[overall.length - 1] - overall[0] : 0,
            historyLength: this.qualityHistory.length
        };
    }
}

module.exports = ${agentName};
`;

        const outputPath = this.outputDir + `/handlers/${agentName}.js`;
        require('fs').writeFileSync(outputPath, qaAgentCode);
        
        console.log(`üîç Generated Data Quality Assurance Agent: ${outputPath}`);
        return outputPath;
    }

    /**
     * Generate geographic risk interpolation agent
     */
    generateGeographicRiskAgent(config) {
        const {
            agentName = 'GeographicRiskInterpolationAgent',
            interpolationMethod = 'inverse_distance_weighting',
            maxRadius = 50000, // 50km
            minDataPoints = 3
        } = config;

        // Generate the geographic risk agent with spatial algorithms
        const geoRiskCode = `/**
 * ${agentName} - Property-level risk interpolation from census tract data
 * Generated by Agent Factory for spatial risk modeling
 */

const { EventEmitter } = require('events');

class ${agentName} extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.config = {
            interpolationMethod: '${interpolationMethod}',
            maxRadius: ${maxRadius},
            minDataPoints: ${minDataPoints},
            distanceDecay: 2, // Power for inverse distance weighting
            elevationAdjustment: true,
            terrainAdjustment: true
        };
        
        // Earth's radius in meters for distance calculations
        this.EARTH_RADIUS = 6371000;
        
        // Risk adjustment factors
        this.adjustmentFactors = {
            elevation: {
                flood: -0.1,    // Higher elevation reduces flood risk
                wildfire: 0.05, // Higher elevation increases wildfire risk
                landslide: 0.08 // Higher elevation increases landslide risk
            },
            slope: {
                flood: -0.05,   // Steeper slopes reduce flood pooling
                landslide: 0.15, // Steeper slopes increase landslide risk
                wildfire: 0.03   // Slopes can increase fire spread
            }
        };
    }

    /**
     * Interpolate property-level risk from nearby data points
     */
    async interpolatePropertyRisk(targetLat, targetLon, nearbyData, options = {}) {
        try {
            console.log(\`Interpolating risk for property at \${targetLat}, \${targetLon}\`);
            
            // Validate input data
            if (!nearbyData || nearbyData.length < this.config.minDataPoints) {
                throw new Error(\`Insufficient data points. Need at least \${this.config.minDataPoints}, got \${nearbyData?.length || 0}\`);
            }
            
            // Calculate distances and weights
            const dataPointsWithDistances = nearbyData.map(dataPoint => {
                const distance = this._calculateDistance(
                    targetLat, targetLon,
                    dataPoint.latitude, dataPoint.longitude
                );
                
                return {
                    ...dataPoint,
                    distance,
                    weight: this._calculateWeight(distance)
                };
            }).filter(point => point.distance <= this.config.maxRadius);
            
            if (dataPointsWithDistances.length === 0) {
                throw new Error(\`No data points within \${this.config.maxRadius}m radius\`);
            }
            
            // Perform interpolation for each hazard type
            const interpolatedRisks = {};
            const availableHazards = this._getAvailableHazards(dataPointsWithDistances);
            
            for (const hazardType of availableHazards) {
                const hazardData = dataPointsWithDistances
                    .filter(point => point.riskScores && point.riskScores[hazardType])
                    .map(point => ({
                        ...point,
                        riskScore: point.riskScores[hazardType].aggregatedScore || point.riskScores[hazardType].score
                    }));
                
                if (hazardData.length > 0) {
                    const baseRisk = this._performInterpolation(hazardData);
                    
                    // Apply terrain and environmental adjustments
                    const adjustedRisk = await this._applyTerrainAdjustments(
                        baseRisk, hazardType, targetLat, targetLon, options
                    );
                    
                    interpolatedRisks[hazardType] = {
                        baseScore: Math.round(baseRisk),
                        adjustedScore: Math.round(adjustedRisk),
                        confidence: this._calculateConfidence(hazardData),
                        dataPointsUsed: hazardData.length,
                        interpolationMethod: this.config.interpolationMethod,
                        lastUpdated: new Date().toISOString()
                    };
                }
            }
            
            // Calculate overall property risk
            const overallRisk = this._calculateOverallRisk(interpolatedRisks);
            
            const result = {
                location: {
                    latitude: targetLat,
                    longitude: targetLon
                },
                hazardRisks: interpolatedRisks,
                overallRisk,
                interpolationMetadata: {
                    nearbyDataPoints: dataPointsWithDistances.length,
                    maxDistance: Math.max(...dataPointsWithDistances.map(p => p.distance)),
                    minDistance: Math.min(...dataPointsWithDistances.map(p => p.distance)),
                    interpolationMethod: this.config.interpolationMethod,
                    terrainAdjustmentsApplied: this.config.elevationAdjustment || this.config.terrainAdjustment,
                    generatedAt: new Date().toISOString()
                }
            };
            
            this.emit('riskInterpolated', {
                location: { latitude: targetLat, longitude: targetLon },
                hazardCount: Object.keys(interpolatedRisks).length,
                confidence: result.overallRisk.confidence
            });
            
            return result;
            
        } catch (error) {
            this.emit('interpolationError', {
                location: { latitude: targetLat, longitude: targetLon },
                error: error.message
            });
            throw error;
        }
    }

    /**
     * Perform the actual interpolation using the configured method
     */
    _performInterpolation(dataPoints) {
        switch (this.config.interpolationMethod) {
            case 'inverse_distance_weighting':
                return this._inverseDistanceWeighting(dataPoints);
            case 'nearest_neighbor':
                return this._nearestNeighbor(dataPoints);
            case 'kriging':
                return this._kriging(dataPoints);
            default:
                return this._inverseDistanceWeighting(dataPoints);
        }
    }

    /**
     * Inverse Distance Weighting interpolation
     */
    _inverseDistanceWeighting(dataPoints) {
        let weightedSum = 0;
        let totalWeight = 0;
        
        dataPoints.forEach(point => {
            if (point.distance === 0) {
                // If we're exactly on a data point, return its value
                return point.riskScore;
            }
            
            const weight = Math.pow(1 / point.distance, this.config.distanceDecay);
            weightedSum += point.riskScore * weight;
            totalWeight += weight;
        });
        
        return totalWeight > 0 ? weightedSum / totalWeight : 0;
    }

    /**
     * Nearest Neighbor interpolation
     */
    _nearestNeighbor(dataPoints) {
        const nearest = dataPoints.reduce((closest, point) => 
            point.distance < closest.distance ? point : closest
        );
        return nearest.riskScore;
    }

    /**
     * Simplified Kriging interpolation
     */
    _kriging(dataPoints) {
        // Simplified implementation - in practice, this would involve
        // variogram modeling and solving systems of linear equations
        
        // For now, use IDW with optimized power parameter
        const originalPower = this.config.distanceDecay;
        this.config.distanceDecay = 1.5; // Optimized for spatial correlation
        
        const result = this._inverseDistanceWeighting(dataPoints);
        this.config.distanceDecay = originalPower; // Restore original
        
        return result;
    }

    /**
     * Apply terrain-based risk adjustments
     */
    async _applyTerrainAdjustments(baseRisk, hazardType, latitude, longitude, options = {}) {
        let adjustedRisk = baseRisk;
        
        try {
            // Get elevation data (would integrate with elevation API in real implementation)
            const elevation = options.elevation || await this._getElevation(latitude, longitude);
            
            // Get slope data (would calculate from DEM in real implementation)
            const slope = options.slope || await this._getSlope(latitude, longitude);
            
            // Apply elevation adjustment
            if (this.config.elevationAdjustment && this.adjustmentFactors.elevation[hazardType]) {
                const elevationFactor = this.adjustmentFactors.elevation[hazardType];
                const normalizedElevation = Math.min(elevation / 1000, 3); // Cap at 3km
                adjustedRisk += adjustedRisk * elevationFactor * normalizedElevation;
            }
            
            // Apply slope adjustment
            if (this.config.terrainAdjustment && this.adjustmentFactors.slope[hazardType]) {
                const slopeFactor = this.adjustmentFactors.slope[hazardType];
                const normalizedSlope = Math.min(slope / 45, 1); // Normalize to max 45 degrees
                adjustedRisk += adjustedRisk * slopeFactor * normalizedSlope;
            }
            
            // Ensure risk stays within valid bounds (0-100)
            adjustedRisk = Math.max(0, Math.min(100, adjustedRisk));
            
        } catch (error) {
            console.warn(\`Terrain adjustment failed: \${error.message}. Using base risk.\`);
        }
        
        return adjustedRisk;
    }

    /**
     * Calculate distance between two points using Haversine formula
     */
    _calculateDistance(lat1, lon1, lat2, lon2) {
        const dLat = this._toRadians(lat2 - lat1);
        const dLon = this._toRadians(lon2 - lon1);
        
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(this._toRadians(lat1)) * Math.cos(this._toRadians(lat2)) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
                
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return this.EARTH_RADIUS * c;
    }

    /**
     * Calculate interpolation weight based on distance
     */
    _calculateWeight(distance) {
        if (distance === 0) return 1;
        return 1 / Math.pow(distance, this.config.distanceDecay);
    }

    /**
     * Calculate confidence based on data point distribution
     */
    _calculateConfidence(dataPoints) {
        if (dataPoints.length < this.config.minDataPoints) return 0;
        
        // Base confidence on number of data points
        const dataPointFactor = Math.min(dataPoints.length / 10, 1);
        
        // Adjust confidence based on distance spread
        const distances = dataPoints.map(p => p.distance);
        const maxDistance = Math.max(...distances);
        const distanceFactor = Math.max(0, 1 - (maxDistance / this.config.maxRadius));
        
        // Adjust confidence based on data point agreement
        const riskScores = dataPoints.map(p => p.riskScore);
        const standardDeviation = this._calculateStandardDeviation(riskScores);
        const mean = riskScores.reduce((sum, score) => sum + score, 0) / riskScores.length;
        const coefficientOfVariation = mean > 0 ? standardDeviation / mean : 1;
        const agreementFactor = Math.max(0, 1 - coefficientOfVariation);
        
        return (dataPointFactor * 0.4) + (distanceFactor * 0.3) + (agreementFactor * 0.3);
    }

    /**
     * Calculate overall property risk from individual hazard risks
     */
    _calculateOverallRisk(hazardRisks) {
        const hazardScores = Object.values(hazardRisks).map(hazard => hazard.adjustedScore);
        
        if (hazardScores.length === 0) {
            return { score: 0, confidence: 0, riskLevel: 'UNKNOWN' };
        }
        
        // Use weighted average with higher weights for extreme risks
        let weightedSum = 0;
        let totalWeight = 0;
        
        hazardScores.forEach(score => {
            const weight = score > 70 ? 1.5 : score > 40 ? 1.2 : 1.0;
            weightedSum += score * weight;
            totalWeight += weight;
        });
        
        const overallScore = Math.round(weightedSum / totalWeight);
        const averageConfidence = Object.values(hazardRisks)
            .reduce((sum, hazard) => sum + hazard.confidence, 0) / Object.keys(hazardRisks).length;
        
        // Determine risk level
        let riskLevel;
        if (overallScore >= 80) riskLevel = 'EXTREME';
        else if (overallScore >= 60) riskLevel = 'VERY_HIGH';
        else if (overallScore >= 40) riskLevel = 'HIGH';
        else if (overallScore >= 20) riskLevel = 'MODERATE';
        else riskLevel = 'LOW';
        
        return {
            score: overallScore,
            confidence: averageConfidence,
            riskLevel,
            hazardCount: Object.keys(hazardRisks).length
        };
    }

    // Helper methods
    _getAvailableHazards(dataPoints) {
        const hazardSet = new Set();
        dataPoints.forEach(point => {
            if (point.riskScores) {
                Object.keys(point.riskScores).forEach(hazard => hazardSet.add(hazard));
            }
        });
        return Array.from(hazardSet);
    }

    _calculateStandardDeviation(values) {
        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
        return Math.sqrt(variance);
    }

    _toRadians(degrees) {
        return degrees * (Math.PI / 180);
    }

    // Placeholder methods for terrain data (would integrate with actual APIs)
    async _getElevation(latitude, longitude) {
        // Would integrate with USGS Elevation API or similar
        return 100; // Placeholder elevation in meters
    }

    async _getSlope(latitude, longitude) {
        // Would calculate from Digital Elevation Model
        return 5; // Placeholder slope in degrees
    }
}

module.exports = ${agentName};
`;

        const outputPath = this.outputDir + `/handlers/${agentName}.js`;
        require('fs').writeFileSync(outputPath, geoRiskCode);
        
        console.log(`üó∫Ô∏è Generated Geographic Risk Interpolation Agent: ${outputPath}`);
        return outputPath;
    }
}

module.exports = ClimateDataProcessingAgent;