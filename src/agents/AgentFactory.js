/**
 * Agent Factory Agent - Self-Bootstrapping Agent Generation System
 * 
 * This agent creates other specialized agents that follow Tim-Combo patterns,
 * including Lambda handlers, TypeScript components, API endpoints, and tests.
 * 
 * Follows all patterns from .clinerules/ and CLAUDE.md files.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class AgentFactory {
  constructor() {
    this.projectRoot = '/Users/jamesford/Source/Tim-Combo';
    this.templatesDir = path.join(this.projectRoot, 'src/agents/templates');
    this.outputDir = path.join(this.projectRoot, 'src/agents/generated');
    
    // Ensure directories exist
    this.ensureDirectoryStructure();
    
    // Load Tim-Combo standards from .clinerules
    this.standards = this.loadTimComboStandards();
  }

  /**
   * Ensure required directory structure exists
   */
  ensureDirectoryStructure() {
    const dirs = [
      this.templatesDir,
      this.outputDir,
      path.join(this.outputDir, 'handlers'),
      path.join(this.outputDir, 'components'),
      path.join(this.outputDir, 'hooks'),
      path.join(this.outputDir, 'types'),
      path.join(this.outputDir, 'tests')
    ];

    dirs.forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        console.log(`📁 Created directory: ${dir}`);
      }
    });
  }

  /**
   * Load Tim-Combo standards from .clinerules files
   */
  loadTimComboStandards() {
    const standardsFiles = [
      'api_standards.md',
      'backend_handler_standards.md', 
      'frontend_standards.md',
      'development_principles.md'
    ];

    const standards = {};
    
    standardsFiles.forEach(file => {
      const filePath = path.join(this.projectRoot, '.clinerules', file);
      if (fs.existsSync(filePath)) {
        standards[file.replace('.md', '')] = fs.readFileSync(filePath, 'utf8');
      }
    });

    return standards;
  }

  /**
   * Generate a specialized Lambda handler following method-specific patterns
   */
  generateLambdaHandler(config) {
    const {
      handlerName,
      httpMethod,
      endpoint,
      description,
      businessLogic,
      queryParams = [],
      bodyParams = [],
      responseType
    } = config;

    // Use method-specific parameter patterns from backend_handler_standards.md
    const parameterPattern = ['GET', 'DELETE'].includes(httpMethod) 
      ? 'queryStringParameters: queryParams = {}'
      : 'body: requestBody = {}';

    const parameterAccess = ['GET', 'DELETE'].includes(httpMethod)
      ? queryParams.map(param => `    const ${param} = queryParams.${param};`).join('\n')
      : bodyParams.map(param => `    const ${param} = requestBody.${param};`).join('\n');

    const handlerCode = `/**
 * ${description}
 * HTTP Method: ${httpMethod} ${endpoint}
 * Generated by Agent Factory following method-specific handler patterns
 */

const { wrapHandler } = require('./lambdaWrapper');
const { executeQuery } = require('./dbOperations');
const { createSuccessResponse, createErrorResponse } = require('./responseUtil');
const { handleError } = require('./errorHandler');

/**
 * ${handlerName} - ${description}
 */
async function ${handlerName}({ ${parameterPattern}, requestContext }) {
    try {
        const Request_ID = requestContext.requestId;
        
        // Extract parameters following method-specific patterns
${parameterAccess}
        
        // Business logic
        ${businessLogic}
        
        // Execute database query
        const query = \`
            -- Generated query for ${handlerName}
            SELECT * FROM table_name WHERE condition = $1
        \`;
        
        const result = await executeQuery(query, [/* parameters */]);
        
        return createSuccessResponse(
            { Records: result.rows },
            '${description} completed successfully',
            {
                Total_Records: result.rows.length,
                Request_ID,
                Timestamp: new Date().toISOString()
            }
        );
        
    } catch (error) {
        console.error('${handlerName} Error:', error);
        return handleError(error);
    }
}

exports.handler = wrapHandler(${handlerName});
`;

    const outputPath = path.join(this.outputDir, 'handlers', `${handlerName}.js`);
    fs.writeFileSync(outputPath, handlerCode);
    
    console.log(`🔧 Generated Lambda handler: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate TypeScript React component following frontend standards
   */
  generateReactComponent(config) {
    const {
      componentName,
      description,
      useContext,
      props = [],
      features = []
    } = config;

    const propsInterface = props.length > 0 
      ? `interface ${componentName}Props {\n${props.map(p => `  ${p.name}: ${p.type};`).join('\n')}\n}`
      : `interface ${componentName}Props {}`;

    const contextImport = useContext 
      ? `import { use${useContext} } from '../../../contexts/${useContext}Context';`
      : '';

    const contextUsage = useContext
      ? `  const { /* context methods */ } = use${useContext}();`
      : '';

    const componentCode = `import { Alert, Button, Card } from 'flowbite-react';
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { HiCheck, HiExclamationCircle } from 'react-icons/hi';
${contextImport}

${propsInterface}

/**
 * ${componentName} - ${description}
 * Generated by Agent Factory following frontend standards
 */
export const ${componentName}: React.FC<${componentName}Props> = React.memo(({
  // destructure props here
}) => {
${contextUsage}
  
  // Local state
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Memoized values
  const processedData = useMemo(() => {
    // Process data here
    return [];
  }, [/* dependencies */]);
  
  // Memoized callbacks
  const handleAction = useCallback(() => {
    // Handle action
  }, [/* dependencies */]);
  
  // Effects
  useEffect(() => {
    // Side effects here
  }, [/* dependencies */]);
  
  // Error handling
  if (error) {
    return (
      <Alert color="failure" icon={HiExclamationCircle}>
        <span className="font-medium">Error: </span>
        {error}
      </Alert>
    );
  }
  
  return (
    <Card className="h-full">
      <div className="p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-gray-900">
            ${componentName}
          </h3>
          {isLoading && (
            <div className="w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full animate-spin" />
          )}
        </div>
        
        <div className="space-y-4">
          {/* Component content here */}
          <p className="text-gray-600">
            ${description}
          </p>
          
          {features.map(feature => (
            <div key={\`feature-\${feature}\`} className="p-3 bg-blue-50 rounded-lg">
              <span className="text-sm text-blue-800">Feature: {feature}</span>
            </div>
          ))}
          
          <Button
            color="blue"
            onClick={handleAction}
            disabled={isLoading}
            className="w-full"
          >
            <HiCheck className="w-4 h-4 mr-2" />
            Action Button
          </Button>
        </div>
      </div>
    </Card>
  );
});

${componentName}.displayName = '${componentName}';

export default ${componentName};
`;

    const outputPath = path.join(this.outputDir, 'components', `${componentName}.tsx`);
    fs.writeFileSync(outputPath, componentCode);
    
    console.log(`⚛️ Generated React component: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate TypeScript types from database schema patterns
   */
  generateTypesFromSchema(config) {
    const {
      tableName,
      description,
      fields,
      relationships = []
    } = config;

    const interfaceName = tableName.split('_').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join('');

    const typeFields = fields.map(field => {
      const optional = field.nullable ? '?' : '';
      return `  ${field.name}${optional}: ${field.tsType};`;
    }).join('\n');

    const relationshipTypes = relationships.map(rel => {
      return `  ${rel.name}?: ${rel.type}[];`;
    }).join('\n');

    const typesCode = `/**
 * TypeScript types for ${tableName}
 * ${description}
 * Generated by Agent Factory from database schema
 */

// Base interface following database field names exactly
export interface ${interfaceName} {
${typeFields}
  
  // Timestamps - required for all entities
  Create_Date: string;
  Last_Updated?: string;
  
  // Relationships
${relationshipTypes}
}

// API Response wrapper following APIResponse<T> pattern
export interface ${interfaceName}Response {
  success: true;
  message: string;
  meta: {
    Total_Records: number;
    Request_ID: string;
    Timestamp: string;
    Company_ID?: string;
  };
  data: {
    Records: ${interfaceName}[];
    Query_Context?: {
      Mode?: string;
      Operation?: string;
      Company_ID?: string;
    };
    Analytics?: {
      Total_Active: number;
      By_Status?: Record<string, number>;
    };
  };
}

// Error response following APIErrorResponse pattern
export interface ${interfaceName}ErrorResponse {
  success: false;
  message: string;
  meta: {
    Timestamp: string;
    Request_ID?: string;
    Error_Source: string;
  };
  error_code: string;
  error_details: string;
  validation_errors?: {
    field: string;
    code: string;
    message: string;
  }[];
}

// Create/Update input types
export type Create${interfaceName}Input = Omit<${interfaceName}, 'Create_Date' | 'Last_Updated'${relationships.length > 0 ? ` | ${relationships.map(r => `'${r.name}'`).join(' | ')}` : ''}>;
export type Update${interfaceName}Input = Partial<Create${interfaceName}Input>;

// Filter and search types
export interface ${interfaceName}Filters {
  Company_ID?: string;
  status?: string;
  dateRange?: {
    start: string;
    end: string;
  };
}

export interface ${interfaceName}SearchParams extends ${interfaceName}Filters {
  limit?: number;
  offset?: number;
  sortBy?: keyof ${interfaceName};
  sortOrder?: 'asc' | 'desc';
}
`;

    const outputPath = path.join(this.outputDir, 'types', `${interfaceName}Types.ts`);
    fs.writeFileSync(outputPath, typesCode);
    
    console.log(`📝 Generated TypeScript types: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate API endpoint configuration following api_standards.md
   */
  generateAPIEndpoints(config) {
    const {
      domain,
      endpoints,
      description
    } = config;

    const endpointConfig = endpoints.map(endpoint => {
      return `    ${endpoint.action}: '${endpoint.path}'${endpoint.comment ? ` // ${endpoint.comment}` : ''}`;
    }).join(',\n');

    const apiCode = `/**
 * API Endpoints for ${domain}
 * ${description}
 * Generated by Agent Factory following API standards
 */

// Add to existing API_ENDPOINTS in apiClient.ts
export const ${domain.toUpperCase()}_ENDPOINTS = {
${endpointConfig}
};

// Usage examples following method-specific patterns:
/*
// GET request - parameters in URL query string
const getResult = await Make_Authorized_API_Call<${domain}Type[]>(
  ${domain.toUpperCase()}_ENDPOINTS.GET,
  'GET',
  undefined,  // No body for GET requests
  { params: { Company_ID: companyId } }
);

// POST request - parameters in request body  
const createResult = await Make_Authorized_API_Call<${domain}Type>(
  ${domain.toUpperCase()}_ENDPOINTS.CREATE,
  'POST',
  { /* body data */ },  // Body data
  undefined  // No URL params for POST requests
);

// PUT request - parameters in request body
const updateResult = await Make_Authorized_API_Call<${domain}Type>(
  ${domain.toUpperCase()}_ENDPOINTS.UPDATE,
  'PUT',
  { /* updated data */ },  // Body data
  undefined  // No URL params for PUT requests
);

// DELETE request - parameters in URL query string
const deleteResult = await Make_Authorized_API_Call<boolean>(
  ${domain.toUpperCase()}_ENDPOINTS.DELETE,
  'DELETE',
  undefined,  // No body for DELETE requests
  { params: { ${domain}_ID: ${domain}Id } }
);
*/
`;

    const outputPath = path.join(this.outputDir, 'types', `${domain}Endpoints.ts`);
    fs.writeFileSync(outputPath, apiCode);
    
    console.log(`🌐 Generated API endpoints: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate comprehensive test suite following Playwright patterns
   */
  generateTestSuite(config) {
    const {
      testName,
      description,
      testType = 'component', // 'component', 'e2e', 'api'
      endpoints = [],
      components = []
    } = config;

    let testCode = '';

    if (testType === 'e2e') {
      testCode = `import { test, expect, Page } from '@playwright/test';

/**
 * E2E Tests for ${testName}
 * ${description}
 * Generated by Agent Factory following Playwright patterns
 */

// Test credentials following established patterns
const TEST_CREDENTIALS = {
  CI_ADMIN: { email: 'dev_c_admin@happyhippo.ai', password: '123_GOtime' },
  TB_ADMIN: { email: 'test_c_admin@happyhippo.ai', password: '123_GOtime' },
  SUPER_ADMIN: { email: 'dev_super@happyhippo.ai', password: '123_GOtime' }
};

test.describe('${testName} E2E Tests', () => {
  
  test.beforeEach(async ({ page }) => {
    // Authentication pattern for specialized dashboards
    await page.goto('/signin');
    await page.fill('input[type="email"]', TEST_CREDENTIALS.CI_ADMIN.email);
    await page.fill('input[type="password"]', TEST_CREDENTIALS.CI_ADMIN.password);
    await page.click('button[type="submit"]');
    await page.waitForURL(/\\/admin\\/dashboard/);
  });

  test('should load dashboard successfully', async ({ page }) => {
    await expect(page.locator('h1')).toContainText('${testName}');
    await expect(page.locator('[data-testid="dashboard-content"]')).toBeVisible();
  });

  test('should handle navigation and workspace switching', async ({ page }) => {
    // Test workspace navigation
    await page.click('[data-testid="workspace-selector"]');
    await expect(page.locator('[data-testid="workspace-options"]')).toBeVisible();
  });

  test('should display data and handle empty states', async ({ page }) => {
    // Check for data or proper empty state
    const hasData = await page.locator('[data-testid="data-content"]').isVisible();
    const hasEmptyState = await page.locator('[data-testid="empty-state"]').isVisible();
    
    expect(hasData || hasEmptyState).toBeTruthy();
  });

});`;
    } else if (testType === 'component') {
      testCode = `import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { ${testName} } from '../${testName}';

/**
 * Component Tests for ${testName}
 * ${description}
 * Generated by Agent Factory following React Testing Library patterns
 */

// Mock contexts if needed
jest.mock('../../contexts/IntegrationDataContext', () => ({
  useIntegrationData: () => ({
    employeeRecords: [],
    loading: { employees: false },
    refreshEmployeeData: jest.fn()
  })
}));

describe('${testName} Component', () => {
  
  const defaultProps = {
    // Add default props here
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders without crashing', () => {
    render(<${testName} {...defaultProps} />);
    expect(screen.getByRole('main')).toBeInTheDocument();
  });

  test('displays loading state correctly', () => {
    render(<${testName} {...defaultProps} />);
    // Test loading state
  });

  test('handles user interactions', async () => {
    render(<${testName} {...defaultProps} />);
    
    const actionButton = screen.getByRole('button', { name: /action/i });
    fireEvent.click(actionButton);
    
    await waitFor(() => {
      // Assert expected behavior
    });
  });

  test('displays error states appropriately', () => {
    render(<${testName} {...defaultProps} />);
    // Test error handling
  });

});`;
    } else if (testType === 'api') {
      testCode = `import request from 'supertest';
import { createTestApp } from '../../../test/helpers/testApp';

/**
 * API Tests for ${testName}
 * ${description}
 * Generated by Agent Factory following API testing patterns
 */

describe('${testName} API Endpoints', () => {
  let app;

  beforeEach(async () => {
    app = await createTestApp();
  });

  afterEach(async () => {
    await app.close();
  });

${endpoints.map(endpoint => `
  describe('${endpoint.method} ${endpoint.path}', () => {
    
    test('should return success response with valid data', async () => {
      const response = await request(app)
        .${endpoint.method.toLowerCase()}('${endpoint.path}')
        .send(${endpoint.method === 'GET' ? '{}' : '{ /* test data */ }'})
        .expect(200);

      expect(response.body).toMatchObject({
        success: true,
        data: {
          Records: expect.any(Array)
        },
        meta: {
          Total_Records: expect.any(Number),
          Request_ID: expect.any(String),
          Timestamp: expect.any(String)
        }
      });
    });

    test('should handle validation errors', async () => {
      const response = await request(app)
        .${endpoint.method.toLowerCase()}('${endpoint.path}')
        .send({})  // Invalid data
        .expect(400);

      expect(response.body).toMatchObject({
        success: false,
        error_code: expect.any(String),
        error_details: expect.any(String)
      });
    });

  });`).join('')}

});`;
    }

    const outputPath = path.join(this.outputDir, 'tests', `${testName}.test.${testType === 'component' ? 'tsx' : 'ts'}`);
    fs.writeFileSync(outputPath, testCode);
    
    console.log(`🧪 Generated ${testType} test: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate a complete feature following all Tim-Combo patterns
   */
  generateCompleteFeature(config) {
    const {
      featureName,
      description,
      domain,
      database,
      api,
      frontend,
      tests
    } = config;

    console.log(`🚀 Generating complete feature: ${featureName}`);
    console.log(`📋 Description: ${description}`);

    const generatedFiles = [];

    // Generate database types
    if (database) {
      generatedFiles.push(this.generateTypesFromSchema({
        tableName: database.tableName,
        description: database.description,
        fields: database.fields,
        relationships: database.relationships
      }));
    }

    // Generate API endpoints
    if (api) {
      generatedFiles.push(this.generateAPIEndpoints({
        domain: domain,
        endpoints: api.endpoints,
        description: api.description
      }));
    }

    // Generate Lambda handlers
    if (api && api.handlers) {
      api.handlers.forEach(handler => {
        generatedFiles.push(this.generateLambdaHandler(handler));
      });
    }

    // Generate React components
    if (frontend && frontend.components) {
      frontend.components.forEach(component => {
        generatedFiles.push(this.generateReactComponent(component));
      });
    }

    // Generate tests
    if (tests) {
      tests.forEach(test => {
        generatedFiles.push(this.generateTestSuite(test));
      });
    }

    // Generate feature documentation
    const docPath = this.generateFeatureDocumentation({
      featureName,
      description,
      generatedFiles,
      domain
    });
    generatedFiles.push(docPath);

    console.log(`✅ Feature '${featureName}' generated successfully!`);
    console.log(`📁 Generated ${generatedFiles.length} files`);
    
    return {
      featureName,
      generatedFiles,
      summary: `Generated complete ${featureName} feature with ${generatedFiles.length} files following Tim-Combo standards`
    };
  }

  /**
   * Generate feature documentation
   */
  generateFeatureDocumentation(config) {
    const { featureName, description, generatedFiles, domain } = config;

    const documentation = `# ${featureName} Feature

${description}

## Generated by Agent Factory

This feature was automatically generated following Tim-Combo standards and patterns from .clinerules/ files.

## Architecture

### Domain: ${domain}

### Generated Files

${generatedFiles.map(file => `- \`${path.relative(this.projectRoot, file)}\``).join('\n')}

## Implementation Checklist

### Backend
- [ ] Review and customize generated Lambda handlers
- [ ] Update database schema if needed
- [ ] Test API endpoints with proper authentication
- [ ] Add business logic to handlers

### Frontend  
- [ ] Review and customize generated React components
- [ ] Integrate components into existing routes
- [ ] Add proper context providers if needed
- [ ] Style components to match design system

### Testing
- [ ] Run generated test suites
- [ ] Add additional test cases for edge scenarios
- [ ] Update E2E tests for new workflows
- [ ] Verify TypeScript compilation

### Deployment
- [ ] Add handlers to SAM/CloudFormation template
- [ ] Deploy to dev environment
- [ ] Test in sandbox environment
- [ ] Update API client configurations

## Standards Compliance

This feature follows all established Tim-Combo patterns:

✅ **API Standards**: APIResponse<T> format with Records array
✅ **Handler Standards**: Method-specific handlers with wrapHandler pattern
✅ **Frontend Standards**: React + TypeScript + Flowbite components
✅ **Error Handling**: Consistent error patterns throughout
✅ **Type Safety**: Complete TypeScript coverage
✅ **Testing**: Comprehensive test coverage

## Next Steps

1. Review generated code for business logic accuracy
2. Customize as needed for specific requirements
3. Integrate into existing application architecture
4. Test thoroughly before deployment
5. Update documentation as needed

Generated on: ${new Date().toISOString()}
Agent Factory Version: 1.0.0
`;

    const outputPath = path.join(this.outputDir, `${featureName}_README.md`);
    fs.writeFileSync(outputPath, documentation);
    
    console.log(`📚 Generated feature documentation: ${outputPath}`);
    return outputPath;
  }

  /**
   * Create an agent that generates other agents (Agent Factory Factory)
   */
  generateAgentFactoryFactory() {
    const factoryFactoryCode = `/**
 * Agent Factory Factory - Creates Agent Factories for different domains
 * 
 * This meta-agent creates specialized Agent Factories for different
 * business domains within Tim-Combo, each with domain-specific patterns.
 */

const AgentFactory = require('./AgentFactory');

class AgentFactoryFactory extends AgentFactory {
  constructor() {
    super();
    this.domainFactories = new Map();
  }

  /**
   * Create a specialized Agent Factory for a specific domain
   */
  createDomainFactory(domain, patterns) {
    const DomainFactory = class extends AgentFactory {
      constructor() {
        super();
        this.domain = domain;
        this.domainPatterns = patterns;
      }

      generateDomainSpecificFeature(config) {
        // Apply domain-specific patterns
        const enhancedConfig = {
          ...config,
          ...this.domainPatterns,
          domain: this.domain
        };

        return this.generateCompleteFeature(enhancedConfig);
      }
    };

    const factory = new DomainFactory();
    this.domainFactories.set(domain, factory);
    
    console.log(\`🏭 Created \${domain} Agent Factory\`);
    return factory;
  }

  /**
   * Get existing domain factory or create new one
   */
  getDomainFactory(domain) {
    if (!this.domainFactories.has(domain)) {
      throw new Error(\`Domain factory for '\${domain}' not found. Create it first with createDomainFactory()\`);
    }
    return this.domainFactories.get(domain);
  }

  /**
   * Bootstrap common Tim-Combo domain factories
   */
  bootstrapCommonFactories() {
    // Integration Domain Factory
    this.createDomainFactory('integration', {
      defaultContext: 'IntegrationData',
      defaultDashboard: 'CI_Admin',
      dataPattern: 'JSONB',
      standardComponents: ['IntegrationWorkflowWidget', 'IntegrationEmployeeWidget']
    });

    // TimeBridge Domain Factory  
    this.createDomainFactory('timebridge', {
      defaultContext: 'TimeBridgeData',
      defaultDashboard: 'TB_Admin',
      dataPattern: 'JSONB',
      standardComponents: ['TimeBridgeSyncStatusWidget', 'TimeBridgeOnboardingWizard']
    });

    // Analytics Domain Factory
    this.createDomainFactory('analytics', {
      defaultContext: 'AnalyticsData',
      defaultDashboard: 'Analytics',
      dataPattern: 'Normalized',
      standardComponents: ['PredictiveApprovalEngine', 'AnalyticsDashboard']
    });

    // Super Admin Domain Factory
    this.createDomainFactory('superadmin', {
      defaultContext: 'SuperAdminStatus',
      defaultDashboard: 'ResponsiveSuperAdminPanel',
      dataPattern: 'Mixed',
      standardComponents: ['CreateIntegrationInstanceAction', 'WorkQueueWidget']
    });

    console.log('🎯 Bootstrapped all common domain factories');
  }
}

module.exports = AgentFactoryFactory;
`;

    const outputPath = path.join(this.outputDir, 'AgentFactoryFactory.js');
    fs.writeFileSync(outputPath, factoryFactoryCode);
    
    console.log(`🏭 Generated Agent Factory Factory: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate deployment and orchestration files
   */
  generateDeploymentOrchestration() {
    const deploymentCode = `/**
 * Agent Deployment Orchestrator
 * 
 * Manages deployment of generated agents and their artifacts
 * following Tim-Combo deployment patterns.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class AgentDeploymentOrchestrator {
  constructor() {
    this.projectRoot = '/Users/jamesford/Source/Tim-Combo';
    this.deploymentQueue = [];
  }

  /**
   * Stage generated artifacts for deployment
   */
  stageArtifacts(generatedFiles) {
    const artifacts = {
      handlers: [],
      components: [],
      types: [],
      tests: []
    };

    generatedFiles.forEach(file => {
      const relativePath = path.relative(this.projectRoot, file);
      
      if (relativePath.includes('/handlers/')) {
        artifacts.handlers.push(file);
      } else if (relativePath.includes('/components/')) {
        artifacts.components.push(file);
      } else if (relativePath.includes('/types/')) {
        artifacts.types.push(file);
      } else if (relativePath.includes('/tests/')) {
        artifacts.tests.push(file);
      }
    });

    this.deploymentQueue.push(artifacts);
    return artifacts;
  }

  /**
   * Deploy Lambda handlers to AWS
   */
  async deployHandlers(handlers) {
    console.log(\`🚀 Deploying \${handlers.length} Lambda handlers...\`);
    
    for (const handler of handlers) {
      const handlerName = path.basename(handler, '.js');
      console.log(\`📦 Packaging \${handlerName}...\`);
      
      // Package handler following Tim-Combo patterns
      const zipCommand = \`cd \${path.dirname(handler)} && zip \${handlerName}.zip \${handlerName}.js\`;
      execSync(zipCommand);
      
      // Upload to S3 bucket
      const uploadCommand = \`aws s3 cp \${handlerName}.zip s3://tim-dev-lambda/ --profile dev-sso\`;
      execSync(uploadCommand);
      
      console.log(\`✅ Deployed \${handlerName}\`);
    }
  }

  /**
   * Deploy frontend components
   */
  async deployComponents(components) {
    console.log(\`⚛️ Deploying \${components.length} React components...\`);
    
    // Run TypeScript compilation check
    execSync('npx tsc --noEmit --project . --pretty', { 
      cwd: path.join(this.projectRoot, 'src/frontend'),
      stdio: 'inherit'
    });
    
    // Build frontend
    execSync('npm run build:sandbox', {
      cwd: path.join(this.projectRoot, 'src/frontend'),
      stdio: 'inherit'
    });
    
    // Deploy to S3
    execSync('aws s3 sync build/ s3://tim-sb-fe-live-855652006097 --profile media-sso --delete', {
      cwd: path.join(this.projectRoot, 'src/frontend'),
      stdio: 'inherit'
    });
    
    console.log('✅ Frontend deployed successfully');
  }

  /**
   * Run generated tests
   */
  async runTests(tests) {
    console.log(\`🧪 Running \${tests.length} test suites...\`);
    
    try {
      // Run TypeScript tests
      execSync('npm test', {
        cwd: path.join(this.projectRoot, 'src/frontend'),
        stdio: 'inherit'
      });
      
      // Run E2E tests
      execSync('npx playwright test --reporter=line', {
        cwd: path.join(this.projectRoot, 'src/frontend'),
        stdio: 'inherit'
      });
      
      console.log('✅ All tests passed');
    } catch (error) {
      console.error('❌ Tests failed:', error.message);
      throw error;
    }
  }

  /**
   * Full deployment pipeline
   */
  async deployComplete(artifacts) {
    console.log('🎯 Starting complete deployment pipeline...');
    
    try {
      // Stage 1: Deploy backend handlers
      if (artifacts.handlers.length > 0) {
        await this.deployHandlers(artifacts.handlers);
      }
      
      // Stage 2: Deploy frontend components  
      if (artifacts.components.length > 0) {
        await this.deployComponents(artifacts.components);
      }
      
      // Stage 3: Run tests
      if (artifacts.tests.length > 0) {
        await this.runTests(artifacts.tests);
      }
      
      console.log('🎉 Deployment pipeline completed successfully!');
      
    } catch (error) {
      console.error('💥 Deployment failed:', error.message);
      throw error;
    }
  }
}

module.exports = AgentDeploymentOrchestrator;
`;

    const outputPath = path.join(this.outputDir, 'AgentDeploymentOrchestrator.js');
    fs.writeFileSync(outputPath, deploymentCode);
    
    console.log(`🚀 Generated Deployment Orchestrator: ${outputPath}`);
    return outputPath;
  }
}

module.exports = AgentFactory;