/**
 * Performance Optimization Agent Template
 * Generated by Agent Factory for Seawater Platform
 * 
 * This template generates specialized agents for optimizing performance of free government data sources
 * with intelligent caching, rate limiting, and predictive data loading.
 */

const AgentFactory = require('../AgentFactory');

class PerformanceOptimizationAgent extends AgentFactory {
    constructor() {
        super();
        this.domain = 'performance-optimization';
        
        // Performance optimization patterns for government data sources
        this.optimizationPatterns = {
            cachingStrategies: {
                'static_data': { ttl: '7days', warmup: true },      // Boundary data, census tracts
                'daily_data': { ttl: '1day', warmup: false },       // Weather data, air quality
                'hourly_data': { ttl: '1hour', warmup: false },     // Real-time alerts
                'realtime_data': { ttl: '5minutes', warmup: false } // Earthquake feeds
            },
            rateLimitStrategies: {
                'aggressive': { requestsPerSecond: 10, burstSize: 50 },
                'moderate': { requestsPerSecond: 5, burstSize: 20 },
                'conservative': { requestsPerSecond: 2, burstSize: 10 }
            },
            preloadingPatterns: {
                'geographic_neighbors': true,  // Pre-load nearby areas
                'temporal_sequences': true,    // Pre-load next time periods
                'related_hazards': true        // Pre-load related risk types
            }
        };
        
        // Government API characteristics for optimization
        this.apiProfiles = {
            fema: {
                latency: 'medium',
                reliability: 'high',
                rateLimit: { requests: 1000, window: 'hour' },
                cachingEffective: true,
                dataUpdateFrequency: 'monthly'
            },
            noaa: {
                latency: 'high',
                reliability: 'high', 
                rateLimit: { requests: 10000, window: 'day' },
                cachingEffective: true,
                dataUpdateFrequency: 'daily'
            },
            usgs: {
                latency: 'low',
                reliability: 'very_high',
                rateLimit: { requests: 'unlimited', window: 'none' },
                cachingEffective: 'moderate',
                dataUpdateFrequency: 'realtime'
            }
        };
    }

    /**
     * Generate intelligent caching agent
     */
    generateIntelligentCachingAgent(config) {
        const {
            agentName = 'IntelligentCacheManager',
            cacheProvider = 'redis',
            predictionEnabled = true,
            compressionEnabled = true,
            metricsEnabled = true
        } = config;

        const cachingAgentCode = `/**
 * ${agentName} - Intelligent multi-tier caching for government climate data
 * Generated by Agent Factory for optimal data access performance
 */

const { EventEmitter } = require('events');
const Redis = require('redis');
const LRU = require('lru-cache');
const zlib = require('zlib');

class ${agentName} extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.config = {
            predictionEnabled: ${predictionEnabled},
            compressionEnabled: ${compressionEnabled},
            metricsEnabled: ${metricsEnabled},
            compressionThreshold: 1024, // bytes
            memoryLimit: 100 * 1024 * 1024, // 100MB
            redisConfig: {
                host: options.redisHost || 'localhost',
                port: options.redisPort || 6379,
                password: options.redisPassword,
                db: options.redisDb || 0
            }
        };
        
        // Initialize cache tiers
        this._initializeCacheTiers();
        
        // Cache performance metrics
        this.metrics = {
            hits: { memory: 0, redis: 0, total: 0 },
            misses: 0,
            sets: 0,
            deletes: 0,
            evictions: 0,
            compressionSaves: 0,
            predictiveLoads: 0,
            averageResponseTime: 0
        };
        
        // Access pattern tracking for predictive caching
        this.accessPatterns = new Map();
        this.maxPatternHistory = 1000;
        
        // Geographic clustering for spatial cache optimization
        this.geographicClusters = new Map();
        this.clusterRadius = 5000; // 5km radius for clustering
        
        // Start background optimization tasks
        if (this.config.predictionEnabled) {
            this._startPredictiveCaching();
        }
        
        this._startMaintenanceTasks();
    }

    /**
     * Initialize multi-tier cache system
     */
    _initializeCacheTiers() {
        // Tier 1: In-memory LRU cache (fastest access)
        this.memoryCache = new LRU({
            max: 500, // Max number of items
            maxSize: this.config.memoryLimit,
            sizeCalculation: (value, key) => {
                return JSON.stringify(value).length + key.length;
            },
            dispose: (value, key, reason) => {
                if (reason === 'evict') {
                    this.metrics.evictions++;
                }
            }
        });
        
        // Tier 2: Redis cache (network-based, persistent)
        this.redisClient = Redis.createClient(this.config.redisConfig);
        
        this.redisClient.on('connect', () => {
            console.log('${agentName}: Connected to Redis cache');
            this.emit('redisCacheConnected');
        });
        
        this.redisClient.on('error', (error) => {
            console.error('${agentName}: Redis connection error:', error);
            this.emit('redisCacheError', error);
        });
        
        this.redisClient.on('ready', () => {
            this.emit('redisCacheReady');
        });
    }

    /**
     * Get data from cache with intelligent tier selection
     */
    async get(key, options = {}) {
        const startTime = Date.now();
        
        try {
            // Track access pattern
            this._trackAccess(key);
            
            // Check memory cache first (Tier 1)
            const memoryResult = this.memoryCache.get(key);
            if (memoryResult) {
                this.metrics.hits.memory++;
                this.metrics.hits.total++;
                this._updateResponseTime(Date.now() - startTime);
                
                this.emit('cacheHit', {
                    key,
                    tier: 'memory',
                    responseTime: Date.now() - startTime
                });
                
                return this._decompressData(memoryResult);
            }
            
            // Check Redis cache (Tier 2)
            const redisResult = await this.redisClient.get(key);
            if (redisResult) {
                this.metrics.hits.redis++;
                this.metrics.hits.total++;
                
                const data = JSON.parse(redisResult);
                const decompressedData = this._decompressData(data);
                
                // Promote to memory cache for future access
                this._setMemoryCache(key, data, options);
                
                this._updateResponseTime(Date.now() - startTime);
                
                this.emit('cacheHit', {
                    key,
                    tier: 'redis',
                    responseTime: Date.now() - startTime
                });
                
                return decompressedData;
            }
            
            // Cache miss
            this.metrics.misses++;
            
            this.emit('cacheMiss', {
                key,
                responseTime: Date.now() - startTime
            });
            
            return null;
            
        } catch (error) {
            this.emit('cacheError', {
                operation: 'get',
                key,
                error: error.message
            });
            return null;
        }
    }

    /**
     * Set data in cache with intelligent tier placement
     */
    async set(key, data, options = {}) {
        const startTime = Date.now();
        
        try {
            const {
                ttl = 3600, // 1 hour default
                priority = 'normal',
                dataType = 'unknown',
                compressible = true
            } = options;
            
            // Determine optimal caching strategy based on data characteristics
            const strategy = this._determineCachingStrategy(key, data, options);
            
            // Compress data if beneficial
            const processedData = this.config.compressionEnabled && compressible
                ? this._compressData(data)
                : { compressed: false, data };
            
            // Set in appropriate cache tiers based on strategy
            const promises = [];
            
            if (strategy.useMemoryCache) {
                this._setMemoryCache(key, processedData, options);
            }
            
            if (strategy.useRedisCache) {
                promises.push(
                    this.redisClient.setEx(key, ttl, JSON.stringify(processedData))
                );
            }
            
            await Promise.all(promises);
            
            this.metrics.sets++;
            this._updateResponseTime(Date.now() - startTime);
            
            // Geographic clustering for spatial optimization
            if (this._isGeographicKey(key)) {
                this._updateGeographicCluster(key, data);
            }
            
            this.emit('cacheSet', {
                key,
                strategy: strategy.name,
                compressed: processedData.compressed,
                ttl,
                responseTime: Date.now() - startTime
            });
            
            // Trigger predictive caching if enabled
            if (this.config.predictionEnabled) {
                this._triggerPredictiveCaching(key, data, options);
            }
            
            return true;
            
        } catch (error) {
            this.emit('cacheError', {
                operation: 'set',
                key,
                error: error.message
            });
            return false;
        }
    }

    /**
     * Delete data from all cache tiers
     */
    async delete(key) {
        try {
            // Remove from memory cache
            this.memoryCache.delete(key);
            
            // Remove from Redis cache
            await this.redisClient.del(key);
            
            this.metrics.deletes++;
            
            this.emit('cacheDelete', { key });
            
            return true;
            
        } catch (error) {
            this.emit('cacheError', {
                operation: 'delete',
                key,
                error: error.message
            });
            return false;
        }
    }

    /**
     * Bulk set operation for efficient batch caching
     */
    async setBulk(dataMap, options = {}) {
        const startTime = Date.now();
        const results = {};
        
        try {
            const pipeline = this.redisClient.multi();
            const memoryOperations = [];
            
            for (const [key, data] of Object.entries(dataMap)) {
                const strategy = this._determineCachingStrategy(key, data, options);
                const processedData = this.config.compressionEnabled 
                    ? this._compressData(data)
                    : { compressed: false, data };
                
                if (strategy.useMemoryCache) {
                    memoryOperations.push(() => this._setMemoryCache(key, processedData, options));
                }
                
                if (strategy.useRedisCache) {
                    const ttl = options.ttl || strategy.defaultTTL;
                    pipeline.setEx(key, ttl, JSON.stringify(processedData));
                }
                
                results[key] = true;
            }
            
            // Execute Redis pipeline
            await pipeline.exec();
            
            // Execute memory cache operations
            memoryOperations.forEach(op => op());
            
            this.metrics.sets += Object.keys(dataMap).length;
            
            this.emit('bulkCacheSet', {
                keyCount: Object.keys(dataMap).length,
                responseTime: Date.now() - startTime
            });
            
            return results;
            
        } catch (error) {
            this.emit('cacheError', {
                operation: 'setBulk',
                error: error.message
            });
            return results;
        }
    }

    /**
     * Determine optimal caching strategy based on data characteristics
     */
    _determineCachingStrategy(key, data, options = {}) {
        const {
            dataType = 'unknown',
            accessFrequency = 'normal',
            dataSize = JSON.stringify(data).length,
            updateFrequency = 'unknown'
        } = options;
        
        // Default strategy
        let strategy = {
            name: 'default',
            useMemoryCache: true,
            useRedisCache: true,
            defaultTTL: 3600
        };
        
        // Government data specific optimizations
        if (key.includes('fema')) {
            strategy = {
                name: 'fema_optimized',
                useMemoryCache: accessFrequency !== 'rare',
                useRedisCache: true,
                defaultTTL: 86400 // 24 hours - FEMA data updates less frequently
            };
        } else if (key.includes('noaa')) {
            strategy = {
                name: 'noaa_optimized',
                useMemoryCache: dataSize < 50000, // Only cache smaller NOAA responses in memory
                useRedisCache: true,
                defaultTTL: 43200 // 12 hours - NOAA data updates daily
            };
        } else if (key.includes('usgs')) {
            strategy = {
                name: 'usgs_optimized',
                useMemoryCache: true,
                useRedisCache: updateFrequency !== 'realtime',
                defaultTTL: 300 // 5 minutes - USGS earthquake data updates frequently
            };
        }
        
        // Size-based optimizations
        if (dataSize > 100000) { // 100KB+
            strategy.useMemoryCache = false; // Don't cache large data in memory
        }
        
        // Access pattern optimizations
        if (accessFrequency === 'high') {
            strategy.useMemoryCache = true;
        } else if (accessFrequency === 'rare') {
            strategy.useMemoryCache = false;
        }
        
        return strategy;
    }

    /**
     * Compress data for efficient storage
     */
    _compressData(data) {
        try {
            const jsonString = JSON.stringify(data);
            
            if (jsonString.length < this.config.compressionThreshold) {
                return { compressed: false, data };
            }
            
            const compressed = zlib.gzipSync(jsonString);
            const compressionRatio = compressed.length / jsonString.length;
            
            // Only use compression if it saves significant space
            if (compressionRatio < 0.8) {
                this.metrics.compressionSaves++;
                return {
                    compressed: true,
                    data: compressed.toString('base64'),
                    originalSize: jsonString.length,
                    compressedSize: compressed.length
                };
            }
            
            return { compressed: false, data };
            
        } catch (error) {
            console.warn('Compression failed:', error.message);
            return { compressed: false, data };
        }
    }

    /**
     * Decompress data from cache
     */
    _decompressData(cachedData) {
        if (!cachedData.compressed) {
            return cachedData.data;
        }
        
        try {
            const compressed = Buffer.from(cachedData.data, 'base64');
            const decompressed = zlib.gunzipSync(compressed);
            return JSON.parse(decompressed.toString());
        } catch (error) {
            console.error('Decompression failed:', error.message);
            return null;
        }
    }

    /**
     * Track access patterns for predictive caching
     */
    _trackAccess(key) {
        if (!this.config.predictionEnabled) return;
        
        const now = Date.now();
        const pattern = this.accessPatterns.get(key) || {
            count: 0,
            lastAccess: 0,
            intervals: [],
            geographic: this._extractGeographicInfo(key)
        };
        
        if (pattern.lastAccess > 0) {
            const interval = now - pattern.lastAccess;
            pattern.intervals.push(interval);
            
            // Keep only recent intervals
            if (pattern.intervals.length > 10) {
                pattern.intervals = pattern.intervals.slice(-10);
            }
        }
        
        pattern.count++;
        pattern.lastAccess = now;
        
        this.accessPatterns.set(key, pattern);
        
        // Cleanup old patterns
        if (this.accessPatterns.size > this.maxPatternHistory) {
            this._cleanupAccessPatterns();
        }
    }

    /**
     * Start predictive caching based on access patterns
     */
    _startPredictiveCaching() {
        setInterval(() => {
            this._predictivelyCache();
        }, 60000); // Run every minute
    }

    /**
     * Predictively cache data based on patterns
     */
    async _predictivelyCache() {
        try {
            const predictions = this._generateCachePredictions();
            
            for (const prediction of predictions) {
                if (prediction.confidence > 0.7 && !await this.get(prediction.key)) {
                    this._requestPredictiveLoad(prediction);
                }
            }
            
        } catch (error) {
            console.warn('Predictive caching failed:', error.message);
        }
    }

    /**
     * Generate cache predictions based on access patterns
     */
    _generateCachePredictions() {
        const predictions = [];
        const now = Date.now();
        
        for (const [key, pattern] of this.accessPatterns) {
            if (pattern.intervals.length < 3) continue;
            
            // Calculate average interval
            const avgInterval = pattern.intervals.reduce((sum, interval) => sum + interval, 0) / pattern.intervals.length;
            
            // Predict next access time
            const predictedNextAccess = pattern.lastAccess + avgInterval;
            const timeToPredicted = predictedNextAccess - now;
            
            // If predicted access is soon and pattern is consistent
            const intervalVariance = this._calculateVariance(pattern.intervals);
            const consistency = 1 / (1 + intervalVariance / avgInterval);
            
            if (timeToPredicted < 300000 && timeToPredicted > 0) { // Next 5 minutes
                predictions.push({
                    key,
                    confidence: consistency * 0.8, // Max 80% confidence
                    timeToAccess: timeToPredicted,
                    avgInterval
                });
            }
            
            // Geographic predictions
            if (pattern.geographic) {
                const neighborKeys = this._getGeographicNeighbors(key);
                neighborKeys.forEach(neighborKey => {
                    if (!this.accessPatterns.has(neighborKey)) {
                        predictions.push({
                            key: neighborKey,
                            confidence: 0.6, // Medium confidence for geographic prediction
                            type: 'geographic',
                            sourceKey: key
                        });
                    }
                });
            }
        }
        
        return predictions.sort((a, b) => b.confidence - a.confidence).slice(0, 10);
    }

    /**
     * Set memory cache with LRU optimization
     */
    _setMemoryCache(key, data, options = {}) {
        try {
            this.memoryCache.set(key, data, {
                ttl: (options.ttl || 3600) * 1000 // Convert to milliseconds
            });
        } catch (error) {
            console.warn('Memory cache set failed:', error.message);
        }
    }

    /**
     * Start maintenance tasks
     */
    _startMaintenanceTasks() {
        // Cache metrics reporting
        if (this.config.metricsEnabled) {
            setInterval(() => {
                this._reportMetrics();
            }, 300000); // Every 5 minutes
        }
        
        // Cleanup expired patterns
        setInterval(() => {
            this._cleanupAccessPatterns();
        }, 600000); // Every 10 minutes
    }

    /**
     * Report cache performance metrics
     */
    _reportMetrics() {
        const hitRate = this.metrics.hits.total / (this.metrics.hits.total + this.metrics.misses) * 100;
        const memoryHitRate = this.metrics.hits.memory / this.metrics.hits.total * 100;
        
        const metrics = {
            hitRate: Math.round(hitRate * 100) / 100,
            memoryHitRate: Math.round(memoryHitRate * 100) / 100,
            totalRequests: this.metrics.hits.total + this.metrics.misses,
            averageResponseTime: Math.round(this.metrics.averageResponseTime),
            memoryUsage: this.memoryCache.size,
            compressionSaves: this.metrics.compressionSaves,
            predictiveLoads: this.metrics.predictiveLoads
        };
        
        this.emit('metricsReport', metrics);
        
        console.log(\`${agentName} Metrics:\`, metrics);
    }

    // Helper methods
    _updateResponseTime(responseTime) {
        if (this.metrics.averageResponseTime === 0) {
            this.metrics.averageResponseTime = responseTime;
        } else {
            this.metrics.averageResponseTime = 
                this.metrics.averageResponseTime * 0.9 + responseTime * 0.1;
        }
    }

    _isGeographicKey(key) {
        return key.includes('lat_') || key.includes('lng_') || key.includes('coords_');
    }

    _extractGeographicInfo(key) {
        const latMatch = key.match(/lat_([\\d.-]+)/);
        const lngMatch = key.match(/lng_([\\d.-]+)/);
        
        if (latMatch && lngMatch) {
            return {
                lat: parseFloat(latMatch[1]),
                lng: parseFloat(lngMatch[1])
            };
        }
        
        return null;
    }

    _updateGeographicCluster(key, data) {
        const geo = this._extractGeographicInfo(key);
        if (!geo) return;
        
        // Simple clustering based on geographic proximity
        const clusterKey = \`cluster_\${Math.round(geo.lat * 100)}_\${Math.round(geo.lng * 100)}\`;
        
        if (!this.geographicClusters.has(clusterKey)) {
            this.geographicClusters.set(clusterKey, new Set());
        }
        
        this.geographicClusters.get(clusterKey).add(key);
    }

    _getGeographicNeighbors(key) {
        const geo = this._extractGeographicInfo(key);
        if (!geo) return [];
        
        const neighbors = [];
        const clusterKey = \`cluster_\${Math.round(geo.lat * 100)}_\${Math.round(geo.lng * 100)}\`;
        
        // Get keys from same cluster
        const cluster = this.geographicClusters.get(clusterKey);
        if (cluster) {
            neighbors.push(...Array.from(cluster).filter(k => k !== key));
        }
        
        // Get keys from adjacent clusters
        for (let latOffset = -1; latOffset <= 1; latOffset++) {
            for (let lngOffset = -1; lngOffset <= 1; lngOffset++) {
                if (latOffset === 0 && lngOffset === 0) continue;
                
                const adjacentKey = \`cluster_\${Math.round(geo.lat * 100) + latOffset}_\${Math.round(geo.lng * 100) + lngOffset}\`;
                const adjacentCluster = this.geographicClusters.get(adjacentKey);
                
                if (adjacentCluster) {
                    neighbors.push(...Array.from(adjacentCluster).slice(0, 3)); // Limit neighbors
                }
            }
        }
        
        return neighbors.slice(0, 10); // Max 10 neighbors
    }

    _calculateVariance(numbers) {
        const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
        const variance = numbers.reduce((sum, num) => sum + Math.pow(num - mean, 2), 0) / numbers.length;
        return variance;
    }

    _cleanupAccessPatterns() {
        const now = Date.now();
        const maxAge = 24 * 60 * 60 * 1000; // 24 hours
        
        for (const [key, pattern] of this.accessPatterns) {
            if (now - pattern.lastAccess > maxAge) {
                this.accessPatterns.delete(key);
            }
        }
    }

    _requestPredictiveLoad(prediction) {
        this.metrics.predictiveLoads++;
        
        this.emit('predictiveLoadRequest', {
            key: prediction.key,
            confidence: prediction.confidence,
            type: prediction.type || 'temporal'
        });
    }

    _triggerPredictiveCaching(key, data, options) {
        // Trigger related data caching based on access patterns
        setTimeout(() => {
            this.emit('triggerPredictiveCaching', { key, data, options });
        }, 100);
    }

    /**
     * Get comprehensive cache statistics
     */
    getStats() {
        const totalRequests = this.metrics.hits.total + this.metrics.misses;
        const hitRate = totalRequests > 0 ? (this.metrics.hits.total / totalRequests) * 100 : 0;
        const memoryHitRate = this.metrics.hits.total > 0 ? (this.metrics.hits.memory / this.metrics.hits.total) * 100 : 0;
        
        return {
            performance: {
                hitRate: Math.round(hitRate * 100) / 100,
                memoryHitRate: Math.round(memoryHitRate * 100) / 100,
                averageResponseTime: Math.round(this.metrics.averageResponseTime),
                totalRequests
            },
            usage: {
                memoryItems: this.memoryCache.size,
                memorySize: this.memoryCache.calculatedSize,
                accessPatterns: this.accessPatterns.size,
                geographicClusters: this.geographicClusters.size
            },
            optimization: {
                compressionSaves: this.metrics.compressionSaves,
                predictiveLoads: this.metrics.predictiveLoads,
                evictions: this.metrics.evictions
            }
        };
    }

    /**
     * Clear all cache tiers
     */
    async clearAll() {
        this.memoryCache.clear();
        await this.redisClient.flushDb();
        this.accessPatterns.clear();
        this.geographicClusters.clear();
        
        // Reset metrics
        Object.keys(this.metrics).forEach(key => {
            if (typeof this.metrics[key] === 'number') {
                this.metrics[key] = 0;
            } else if (typeof this.metrics[key] === 'object') {
                Object.keys(this.metrics[key]).forEach(subKey => {
                    this.metrics[key][subKey] = 0;
                });
            }
        });
        
        this.emit('cacheClearAll');
    }
}

module.exports = ${agentName};
`;

        const outputPath = this.outputDir + `/handlers/${agentName}.js`;
        require('fs').writeFileSync(outputPath, cachingAgentCode);
        
        console.log(`âš¡ Generated Intelligent Caching Agent: ${outputPath}`);
        return outputPath;
    }

    /**
     * Generate adaptive rate limiting agent
     */
    generateRateLimitingAgent(config) {
        const {
            agentName = 'AdaptiveRateLimitingAgent',
            algorithm = 'token_bucket',
            adaptiveStrategy = true,
            backoffStrategy = 'exponential_jitter'
        } = config;

        const rateLimitingCode = `/**
 * ${agentName} - Adaptive rate limiting for government API optimization
 * Generated by Agent Factory for optimal API usage within constraints
 */

const { EventEmitter } = require('events');

class ${agentName} extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.config = {
            algorithm: '${algorithm}',
            adaptiveStrategy: ${adaptiveStrategy},
            backoffStrategy: '${backoffStrategy}',
            windowSize: 3600000, // 1 hour in milliseconds
            minRequestInterval: 100, // Minimum time between requests
            maxConcurrentRequests: 10
        };
        
        // Rate limit configurations per API
        this.apiLimits = {
            fema: {
                requestsPerHour: 1000,
                burstSize: 50,
                priority: 'high'
            },
            noaa: {
                requestsPerHour: 417, // 10,000 per day / 24 hours
                burstSize: 20,
                priority: 'medium'
            },
            usgs: {
                requestsPerHour: 3600, // Unlimited, but be reasonable
                burstSize: 100,
                priority: 'low'
            }
        };
        
        // Token buckets for each API
        this.tokenBuckets = new Map();
        this.requestQueues = new Map();
        this.requestHistory = new Map();
        
        // Adaptive learning data
        this.adaptiveData = {
            successRates: new Map(),
            responseLatencies: new Map(),
            errorPatterns: new Map(),
            optimalRates: new Map()
        };
        
        // Initialize token buckets
        this._initializeTokenBuckets();
        
        // Start maintenance tasks
        this._startMaintenanceTasks();
        
        // Statistics
        this.stats = {
            totalRequests: 0,
            successfulRequests: 0,
            rateLimitedRequests: 0,
            queuedRequests: 0,
            averageWaitTime: 0,
            apiUsage: new Map()
        };
    }

    /**
     * Request permission to make API call
     */
    async requestAccess(apiSource, options = {}) {
        const {
            priority = 'normal',
            maxWaitTime = 30000, // 30 seconds max wait
            metadata = {}
        } = options;
        
        const startTime = Date.now();
        
        try {
            // Check if request is allowed
            const permission = await this._checkRateLimit(apiSource, priority);
            
            if (permission.allowed) {
                // Consume token and proceed
                this._consumeToken(apiSource);
                this._recordRequest(apiSource, true, Date.now() - startTime);
                
                this.emit('requestGranted', {
                    apiSource,
                    priority,
                    waitTime: 0,
                    tokensRemaining: permission.tokensRemaining
                });
                
                return { granted: true, waitTime: 0 };
            }
            
            // Request needs to wait or be queued
            if (permission.suggestedWaitTime <= maxWaitTime) {
                const actualWaitTime = await this._waitForToken(apiSource, permission.suggestedWaitTime);
                
                this._recordRequest(apiSource, true, actualWaitTime);
                this.stats.queuedRequests++;
                
                this.emit('requestGranted', {
                    apiSource,
                    priority,
                    waitTime: actualWaitTime,
                    tokensRemaining: this._getRemainingTokens(apiSource)
                });
                
                return { granted: true, waitTime: actualWaitTime };
            }
            
            // Request cannot be fulfilled within acceptable time
            this.stats.rateLimitedRequests++;
            
            this.emit('requestDenied', {
                apiSource,
                reason: 'rate_limit_exceeded',
                suggestedWaitTime: permission.suggestedWaitTime,
                maxWaitTime
            });
            
            return { 
                granted: false, 
                reason: 'rate_limit_exceeded',
                suggestedRetryAfter: permission.suggestedWaitTime
            };
            
        } catch (error) {
            this.emit('rateLimitError', {
                apiSource,
                error: error.message
            });
            
            // Fail open - allow request but log error
            return { granted: true, waitTime: 0, warning: error.message };
        }
    }

    /**
     * Report API request result for adaptive optimization
     */
    recordRequestResult(apiSource, result) {
        const {
            success = true,
            responseTime = 0,
            statusCode = 200,
            errorType = null,
            rateLimitHeaders = {}
        } = result;
        
        // Update success rate tracking
        const successHistory = this.adaptiveData.successRates.get(apiSource) || [];
        successHistory.push({ success, timestamp: Date.now() });
        
        // Keep only recent history (last 100 requests)
        if (successHistory.length > 100) {
            successHistory.shift();
        }
        this.adaptiveData.successRates.set(apiSource, successHistory);
        
        // Update latency tracking
        if (responseTime > 0) {
            const latencyHistory = this.adaptiveData.responseLatencies.get(apiSource) || [];
            latencyHistory.push({ latency: responseTime, timestamp: Date.now() });
            
            if (latencyHistory.length > 100) {
                latencyHistory.shift();
            }
            this.adaptiveData.responseLatencies.set(apiSource, latencyHistory);
        }
        
        // Track error patterns
        if (!success && errorType) {
            const errorHistory = this.adaptiveData.errorPatterns.get(apiSource) || new Map();
            const errorCount = errorHistory.get(errorType) || 0;
            errorHistory.set(errorType, errorCount + 1);
            this.adaptiveData.errorPatterns.set(apiSource, errorHistory);
        }
        
        // Learn from rate limit headers
        if (rateLimitHeaders.remaining !== undefined) {
            this._updateFromRateLimitHeaders(apiSource, rateLimitHeaders);
        }
        
        // Update statistics
        this.stats.totalRequests++;
        if (success) {
            this.stats.successfulRequests++;
        }
        
        // Update API-specific usage stats
        const apiStats = this.stats.apiUsage.get(apiSource) || { total: 0, success: 0 };
        apiStats.total++;
        if (success) apiStats.success++;
        this.stats.apiUsage.set(apiSource, apiStats);
        
        // Adaptive rate adjustment
        if (this.config.adaptiveStrategy) {
            this._adaptiveRateAdjustment(apiSource);
        }
    }

    /**
     * Initialize token buckets for each API
     */
    _initializeTokenBuckets() {
        for (const [apiSource, limits] of Object.entries(this.apiLimits)) {
            this.tokenBuckets.set(apiSource, {
                capacity: limits.burstSize,
                tokens: limits.burstSize,
                refillRate: limits.requestsPerHour / 3600, // tokens per second
                lastRefill: Date.now(),
                priority: limits.priority
            });
            
            this.requestQueues.set(apiSource, []);
            this.requestHistory.set(apiSource, []);
        }
    }

    /**
     * Check if request is within rate limits
     */
    async _checkRateLimit(apiSource, priority) {
        const bucket = this.tokenBuckets.get(apiSource);
        if (!bucket) {
            throw new Error(\`Unknown API source: \${apiSource}\`);
        }
        
        // Refill tokens based on elapsed time
        this._refillTokens(apiSource);
        
        if (bucket.tokens >= 1) {
            return {
                allowed: true,
                tokensRemaining: bucket.tokens - 1
            };
        }
        
        // Calculate suggested wait time
        const tokensNeeded = 1;
        const refillTime = (tokensNeeded / bucket.refillRate) * 1000; // Convert to milliseconds
        
        return {
            allowed: false,
            suggestedWaitTime: Math.ceil(refillTime),
            tokensRemaining: 0
        };
    }

    /**
     * Refill tokens based on elapsed time
     */
    _refillTokens(apiSource) {
        const bucket = this.tokenBuckets.get(apiSource);
        const now = Date.now();
        const elapsed = (now - bucket.lastRefill) / 1000; // Convert to seconds
        
        const tokensToAdd = elapsed * bucket.refillRate;
        bucket.tokens = Math.min(bucket.capacity, bucket.tokens + tokensToAdd);
        bucket.lastRefill = now;
    }

    /**
     * Consume a token from the bucket
     */
    _consumeToken(apiSource) {
        const bucket = this.tokenBuckets.get(apiSource);
        bucket.tokens = Math.max(0, bucket.tokens - 1);
    }

    /**
     * Wait for token availability
     */
    async _waitForToken(apiSource, suggestedWaitTime) {
        return new Promise((resolve) => {
            const waitTime = Math.min(suggestedWaitTime, 30000); // Max 30 seconds
            
            setTimeout(() => {
                resolve(waitTime);
            }, waitTime);
        });
    }

    /**
     * Get remaining tokens for an API
     */
    _getRemainingTokens(apiSource) {
        this._refillTokens(apiSource);
        const bucket = this.tokenBuckets.get(apiSource);
        return Math.floor(bucket.tokens);
    }

    /**
     * Record request for tracking purposes
     */
    _recordRequest(apiSource, success, responseTime) {
        const history = this.requestHistory.get(apiSource) || [];
        history.push({
            timestamp: Date.now(),
            success,
            responseTime
        });
        
        // Keep only recent history (last 1000 requests)
        if (history.length > 1000) {
            history.shift();
        }
        
        this.requestHistory.set(apiSource, history);
        
        // Update average wait time
        if (responseTime > 0) {
            if (this.stats.averageWaitTime === 0) {
                this.stats.averageWaitTime = responseTime;
            } else {
                this.stats.averageWaitTime = 
                    this.stats.averageWaitTime * 0.9 + responseTime * 0.1;
            }
        }
    }

    /**
     * Adaptive rate adjustment based on API performance
     */
    _adaptiveRateAdjustment(apiSource) {
        const successHistory = this.adaptiveData.successRates.get(apiSource) || [];
        const latencyHistory = this.adaptiveData.responseLatencies.get(apiSource) || [];
        
        if (successHistory.length < 10) return; // Need enough data
        
        // Calculate recent success rate (last 20 requests)
        const recentSuccess = successHistory.slice(-20);
        const successRate = recentSuccess.filter(r => r.success).length / recentSuccess.length;
        
        // Calculate average latency
        const recentLatency = latencyHistory.slice(-20);
        const avgLatency = recentLatency.length > 0 
            ? recentLatency.reduce((sum, r) => sum + r.latency, 0) / recentLatency.length 
            : 1000;
        
        // Adjust rate based on performance
        const bucket = this.tokenBuckets.get(apiSource);
        const originalRate = this.apiLimits[apiSource].requestsPerHour / 3600;
        
        let adjustmentFactor = 1.0;
        
        // Reduce rate if success rate is low
        if (successRate < 0.8) {
            adjustmentFactor *= 0.7;
        } else if (successRate > 0.95) {
            adjustmentFactor *= 1.1;
        }
        
        // Reduce rate if latency is high
        if (avgLatency > 5000) { // 5 seconds
            adjustmentFactor *= 0.8;
        } else if (avgLatency < 1000) { // 1 second
            adjustmentFactor *= 1.05;
        }
        
        // Apply bounds to adjustment
        adjustmentFactor = Math.max(0.1, Math.min(2.0, adjustmentFactor));
        
        bucket.refillRate = originalRate * adjustmentFactor;
        
        this.emit('rateAdjusted', {
            apiSource,
            originalRate,
            newRate: bucket.refillRate,
            adjustmentFactor,
            successRate,
            avgLatency
        });
    }

    /**
     * Update rate limits based on API response headers
     */
    _updateFromRateLimitHeaders(apiSource, headers) {
        const {
            remaining = null,
            limit = null,
            reset = null,
            retryAfter = null
        } = headers;
        
        if (remaining !== null && limit !== null) {
            const bucket = this.tokenBuckets.get(apiSource);
            
            // Update token count based on server information
            const serverTokens = Math.max(0, parseInt(remaining));
            
            // Use the minimum of our calculation and server information
            bucket.tokens = Math.min(bucket.tokens, serverTokens);
            
            this.emit('rateLimitHeadersProcessed', {
                apiSource,
                remaining: serverTokens,
                limit: parseInt(limit),
                reset: reset ? new Date(parseInt(reset) * 1000) : null
            });
        }
    }

    /**
     * Start maintenance tasks
     */
    _startMaintenanceTasks() {
        // Regular token bucket maintenance
        setInterval(() => {
            for (const apiSource of this.tokenBuckets.keys()) {
                this._refillTokens(apiSource);
            }
        }, 1000); // Every second
        
        // Adaptive optimization
        if (this.config.adaptiveStrategy) {
            setInterval(() => {
                for (const apiSource of this.tokenBuckets.keys()) {
                    this._adaptiveRateAdjustment(apiSource);
                }
            }, 60000); // Every minute
        }
        
        // Cleanup old data
        setInterval(() => {
            this._cleanupHistoricalData();
        }, 300000); // Every 5 minutes
        
        // Performance reporting
        setInterval(() => {
            this._reportPerformanceMetrics();
        }, 300000); // Every 5 minutes
    }

    /**
     * Cleanup old historical data
     */
    _cleanupHistoricalData() {
        const maxAge = 24 * 60 * 60 * 1000; // 24 hours
        const cutoff = Date.now() - maxAge;
        
        // Cleanup request history
        for (const [apiSource, history] of this.requestHistory) {
            const filteredHistory = history.filter(record => record.timestamp > cutoff);
            this.requestHistory.set(apiSource, filteredHistory);
        }
        
        // Cleanup adaptive data
        for (const [apiSource, successHistory] of this.adaptiveData.successRates) {
            const filteredHistory = successHistory.filter(record => record.timestamp > cutoff);
            this.adaptiveData.successRates.set(apiSource, filteredHistory);
        }
        
        for (const [apiSource, latencyHistory] of this.adaptiveData.responseLatencies) {
            const filteredHistory = latencyHistory.filter(record => record.timestamp > cutoff);
            this.adaptiveData.responseLatencies.set(apiSource, filteredHistory);
        }
    }

    /**
     * Report performance metrics
     */
    _reportPerformanceMetrics() {
        const totalRequests = this.stats.totalRequests;
        const successRate = totalRequests > 0 ? (this.stats.successfulRequests / totalRequests) * 100 : 0;
        const rateLimitRate = totalRequests > 0 ? (this.stats.rateLimitedRequests / totalRequests) * 100 : 0;
        
        const metrics = {
            overall: {
                totalRequests,
                successRate: Math.round(successRate * 100) / 100,
                rateLimitRate: Math.round(rateLimitRate * 100) / 100,
                averageWaitTime: Math.round(this.stats.averageWaitTime),
                queuedRequests: this.stats.queuedRequests
            },
            perAPI: {}
        };
        
        // Per-API metrics
        for (const [apiSource, bucket] of this.tokenBuckets) {
            const apiStats = this.stats.apiUsage.get(apiSource) || { total: 0, success: 0 };
            const apiSuccessRate = apiStats.total > 0 ? (apiStats.success / apiStats.total) * 100 : 0;
            
            metrics.perAPI[apiSource] = {
                currentTokens: Math.floor(bucket.tokens),
                capacity: bucket.capacity,
                refillRate: Math.round(bucket.refillRate * 3600), // Per hour
                totalRequests: apiStats.total,
                successRate: Math.round(apiSuccessRate * 100) / 100
            };
        }
        
        this.emit('performanceMetrics', metrics);
        
        console.log(\`${agentName} Performance:\`, metrics.overall);
    }

    /**
     * Get current rate limiting status
     */
    getStatus() {
        const status = {
            apis: {},
            overall: {
                totalRequests: this.stats.totalRequests,
                successRate: this.stats.totalRequests > 0 
                    ? Math.round((this.stats.successfulRequests / this.stats.totalRequests) * 100)
                    : 0,
                rateLimitedRequests: this.stats.rateLimitedRequests
            }
        };
        
        for (const [apiSource, bucket] of this.tokenBuckets) {
            this._refillTokens(apiSource);
            
            status.apis[apiSource] = {
                tokensAvailable: Math.floor(bucket.tokens),
                capacity: bucket.capacity,
                refillRate: Math.round(bucket.refillRate * 3600), // requests per hour
                isThrottled: bucket.tokens < 1
            };
        }
        
        return status;
    }

    /**
     * Reset rate limiter state
     */
    reset() {
        // Reset token buckets
        for (const [apiSource, limits] of Object.entries(this.apiLimits)) {
            const bucket = this.tokenBuckets.get(apiSource);
            bucket.tokens = bucket.capacity;
            bucket.lastRefill = Date.now();
        }
        
        // Clear history
        this.requestHistory.clear();
        this.adaptiveData.successRates.clear();
        this.adaptiveData.responseLatencies.clear();
        this.adaptiveData.errorPatterns.clear();
        
        // Reset stats
        this.stats = {
            totalRequests: 0,
            successfulRequests: 0,
            rateLimitedRequests: 0,
            queuedRequests: 0,
            averageWaitTime: 0,
            apiUsage: new Map()
        };
        
        this.emit('rateLimiterReset');
    }
}

module.exports = ${agentName};
`;

        const outputPath = this.outputDir + `/handlers/${agentName}.js`;
        require('fs').writeFileSync(outputPath, rateLimitingCode);
        
        console.log(`ðŸš¦ Generated Adaptive Rate Limiting Agent: ${outputPath}`);
        return outputPath;
    }
}

module.exports = PerformanceOptimizationAgent;