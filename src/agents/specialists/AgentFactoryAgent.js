/**
 * Agent Factory Agent - Self-Bootstrapping Agent Generation System
 * 
 * This agent creates other specialized agents that follow Equilateral AI patterns,
 * including Lambda handlers, TypeScript components, API endpoints, and tests.
 * 
 * Copyright (c) 2025 Equilateral AI (Pareidolia LLC)
 * Integrated from multi-project innovations into core system.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class AgentFactoryAgent {
  constructor() {
    this.projectRoot = process.cwd();
    this.templatesDir = path.join(this.projectRoot, 'src/agents/templates');
    this.outputDir = path.join(this.projectRoot, 'src/agents/generated');
    
    // Ensure directories exist
    this.ensureDirectoryStructure();
    
    // Load Tim-Combo standards from .clinerules
    this.standards = this.loadTimComboStandards();
  }

  /**
   * Ensure required directory structure exists
   */
  ensureDirectoryStructure() {
    const dirs = [
      this.templatesDir,
      this.outputDir,
      path.join(this.outputDir, 'handlers'),
      path.join(this.outputDir, 'components'),
      path.join(this.outputDir, 'hooks'),
      path.join(this.outputDir, 'types'),
      path.join(this.outputDir, 'tests')
    ];

    dirs.forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        console.log(`ðŸ“ Created directory: ${dir}`);
      }
    });
  }

  /**
   * Load Tim-Combo standards from .clinerules files
   */
  loadTimComboStandards() {
    const standardsFiles = [
      'api_standards.md',
      'backend_handler_standards.md', 
      'frontend_standards.md',
      'development_principles.md'
    ];

    const standards = {};
    
    standardsFiles.forEach(file => {
      const filePath = path.join(this.projectRoot, '.clinerules', file);
      if (fs.existsSync(filePath)) {
        standards[file.replace('.md', '')] = fs.readFileSync(filePath, 'utf8');
      }
    });

    return standards;
  }

  /**
   * Generate a specialized Lambda handler following method-specific patterns
   */
  generateLambdaHandler(config) {
    const {
      handlerName,
      httpMethod,
      endpoint,
      description,
      businessLogic,
      queryParams = [],
      bodyParams = [],
      responseType
    } = config;

    // Use method-specific parameter patterns from backend_handler_standards.md
    const parameterPattern = ['GET', 'DELETE'].includes(httpMethod) 
      ? 'queryStringParameters: queryParams = {}'
      : 'body: requestBody = {}';

    const parameterAccess = ['GET', 'DELETE'].includes(httpMethod)
      ? queryParams.map(param => `    const ${param} = queryParams.${param};`).join('\n')
      : bodyParams.map(param => `    const ${param} = requestBody.${param};`).join('\n');

    const handlerCode = `/**
 * ${description}
 * HTTP Method: ${httpMethod} ${endpoint}
 * Generated by Agent Factory following method-specific handler patterns
 */

const { wrapHandler } = require('./lambdaWrapper');
const { executeQuery } = require('./dbOperations');
const { createSuccessResponse, createErrorResponse } = require('./responseUtil');
const { handleError } = require('./errorHandler');

/**
 * ${handlerName} - ${description}
 */
async function ${handlerName}({ ${parameterPattern}, requestContext }) {
    try {
        const Request_ID = requestContext.requestId;
        
        // Extract parameters following method-specific patterns
${parameterAccess}
        
        // Business logic
        ${businessLogic}
        
        // Execute database query
        const query = \`
            -- Generated query for ${handlerName}
            SELECT * FROM table_name WHERE condition = $1
        \`;
        
        const result = await executeQuery(query, [/* parameters */]);
        
        return createSuccessResponse(
            { Records: result.rows },
            '${description} completed successfully',
            {
                Total_Records: result.rows.length,
                Request_ID,
                Timestamp: new Date().toISOString()
            }
        );
        
    } catch (error) {
        console.error('${handlerName} Error:', error);
        return handleError(error);
    }
}

exports.handler = wrapHandler(${handlerName});
`;

    const outputPath = path.join(this.outputDir, 'handlers', `${handlerName}.js`);
    fs.writeFileSync(outputPath, handlerCode);
    
    console.log(`ðŸ”§ Generated Lambda handler: ${outputPath}`);
    return outputPath;
  }

  /**
   * Generate complete feature following all Tim-Combo patterns
   */
  generateCompleteFeature(config) {
    const {
      featureName,
      description,
      domain,
      database,
      api,
      frontend,
      tests
    } = config;

    console.log(`ðŸš€ Generating complete feature: ${featureName}`);
    console.log(`ðŸ“‹ Description: ${description}`);

    const generatedFiles = [];

    // Generate database types
    if (database) {
      generatedFiles.push(this.generateTypesFromSchema({
        tableName: database.tableName,
        description: database.description,
        fields: database.fields,
        relationships: database.relationships
      }));
    }

    // Generate API endpoints
    if (api) {
      generatedFiles.push(this.generateAPIEndpoints({
        domain: domain,
        endpoints: api.endpoints,
        description: api.description
      }));
    }

    // Generate Lambda handlers
    if (api && api.handlers) {
      api.handlers.forEach(handler => {
        generatedFiles.push(this.generateLambdaHandler(handler));
      });
    }

    console.log(`âœ… Feature '${featureName}' generated successfully!`);
    console.log(`ðŸ“ Generated ${generatedFiles.length} files`);
    
    return {
      featureName,
      generatedFiles,
      summary: `Generated complete ${featureName} feature with ${generatedFiles.length} files following Tim-Combo standards`
    };
  }

  /**
   * Create domain-specific agent extension
   */
  createDomainExtension(domain, extensionConfig) {
    const { baseAgent, domainCapabilities, patterns } = extensionConfig;
    
    const extensionCode = `/**
 * ${domain} Domain Extension for ${baseAgent}
 * Generated by Agent Factory
 */

const ${baseAgent} = require('../${baseAgent}');

class ${domain}${baseAgent} extends ${baseAgent} {
    constructor(config) {
        super(config);
        this.domain = '${domain}';
        this.domainCapabilities = ${JSON.stringify(domainCapabilities, null, 8)};
        this.domainPatterns = ${JSON.stringify(patterns, null, 8)};
    }

    // Domain-specific method extensions
    ${domainCapabilities.map(capability => `
    async ${capability}(context) {
        // Apply domain-specific patterns
        const domainContext = {
            ...context,
            domain: this.domain,
            patterns: this.domainPatterns
        };
        
        // Call base capability with domain enhancements
        const baseResult = await super.performAnalysis?.(domainContext) || {};
        
        // Add domain-specific analysis
        const domainResult = await this.performDomainAnalysis(domainContext);
        
        return this.mergeDomainResults(baseResult, domainResult);
    }`).join('')}

    async performDomainAnalysis(context) {
        // Domain-specific analysis logic
        return {
            domain: this.domain,
            analysis: 'Domain-specific analysis completed',
            patterns_applied: this.domainPatterns,
            timestamp: new Date().toISOString()
        };
    }

    mergeDomainResults(baseResult, domainResult) {
        return {
            ...baseResult,
            domain_analysis: domainResult,
            enhanced: true
        };
    }
}

module.exports = ${domain}${baseAgent};
`;

    const outputPath = path.join(this.outputDir, `${domain}${baseAgent}.js`);
    fs.writeFileSync(outputPath, extensionCode);
    
    console.log(`ðŸŽ¯ Generated domain extension: ${outputPath}`);
    return outputPath;
  }
}

module.exports = AgentFactoryAgent;