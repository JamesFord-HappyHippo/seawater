# Disaster Recovery and Business Continuity for Seawater Platform
# This template creates multi-region backup, failover capabilities, and recovery procedures

AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'Disaster recovery and business continuity for Seawater Climate Risk Platform'

Parameters:
  Environment:
    Type: String
    Default: production
    AllowedValues: [dev, staging, production]
  
  ProjectName:
    Type: String
    Default: seawater
  
  PrimaryRegion:
    Type: String
    Default: us-east-1
    Description: 'Primary AWS region'
  
  SecondaryRegion:
    Type: String
    Default: us-west-2
    Description: 'Secondary AWS region for DR'
  
  RPOHours:
    Type: Number
    Default: 4
    Description: 'Recovery Point Objective in hours'
  
  RTOMinutes:
    Type: Number
    Default: 60
    Description: 'Recovery Time Objective in minutes'

Conditions:
  IsProduction: !Equals [!Ref Environment, 'production']
  EnableCrossRegionReplication: !Condition IsProduction

Resources:
  # ==================== CROSS-REGION S3 REPLICATION ====================
  
  # Secondary region S3 bucket for data replication
  SecondaryDataBucket:
    Type: AWS::S3::Bucket
    Condition: EnableCrossRegionReplication
    Properties:
      BucketName: !Sub '${ProjectName}-${Environment}-data-dr-${AWS::AccountId}'
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: TransitionToIA
            Status: Enabled
            Transition:
              Days: 30
              StorageClass: STANDARD_IA
          - Id: TransitionToGlacier
            Status: Enabled
            Transition:
              Days: 90
              StorageClass: GLACIER
      Tags:
        - Key: Purpose
          Value: DisasterRecovery
        - Key: Environment
          Value: !Ref Environment

  # IAM role for S3 replication
  S3ReplicationRole:
    Type: AWS::IAM::Role
    Condition: EnableCrossRegionReplication
    Properties:
      RoleName: !Sub '${ProjectName}-${Environment}-s3-replication-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: s3.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: S3ReplicationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 's3:GetObjectVersionForReplication'
                  - 's3:GetObjectVersionAcl'
                Resource: !Sub 'arn:aws:s3:::${ProjectName}-${Environment}-data-${AWS::AccountId}/*'
              - Effect: Allow
                Action:
                  - 's3:ListBucket'
                Resource: !Sub 'arn:aws:s3:::${ProjectName}-${Environment}-data-${AWS::AccountId}'
              - Effect: Allow
                Action:
                  - 's3:ReplicateObject'
                  - 's3:ReplicateDelete'
                Resource: !Sub 'arn:aws:s3:::${ProjectName}-${Environment}-data-dr-${AWS::AccountId}/*'

  # ==================== DATABASE DISASTER RECOVERY ====================
  
  # Cross-region automated backups
  DatabaseBackupVault:
    Type: AWS::Backup::BackupVault
    Condition: IsProduction
    Properties:
      BackupVaultName: !Sub '${ProjectName}-${Environment}-db-backup-vault'
      EncryptionKeyArn: !GetAtt BackupVaultKey.Arn
      BackupVaultTags:
        Environment: !Ref Environment
        Purpose: DisasterRecovery

  BackupVaultKey:
    Type: AWS::KMS::Key
    Condition: IsProduction
    Properties:
      Description: 'KMS key for backup vault encryption'
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'
          - Sid: Allow AWS Backup Service
            Effect: Allow
            Principal:
              Service: backup.amazonaws.com
            Action:
              - 'kms:Decrypt'
              - 'kms:GenerateDataKey'
              - 'kms:CreateGrant'
            Resource: '*'

  BackupVaultKeyAlias:
    Type: AWS::KMS::Alias
    Condition: IsProduction
    Properties:
      AliasName: !Sub 'alias/${ProjectName}-${Environment}-backup-vault'
      TargetKeyId: !Ref BackupVaultKey

  # Backup plan for RDS
  DatabaseBackupPlan:
    Type: AWS::Backup::BackupPlan
    Condition: IsProduction
    Properties:
      BackupPlan:
        BackupPlanName: !Sub '${ProjectName}-${Environment}-db-backup-plan'
        BackupPlanRule:
          - RuleName: DailyBackups
            TargetBackupVault: !Ref DatabaseBackupVault
            ScheduleExpression: 'cron(0 2 ? * * *)'  # 2 AM daily
            StartWindowMinutes: 60
            CompletionWindowMinutes: 120
            Lifecycle:
              DeleteAfterDays: 30
              MoveToColdStorageAfterDays: 7
            RecoveryPointTags:
              Environment: !Ref Environment
              BackupType: Daily
          - RuleName: WeeklyBackups
            TargetBackupVault: !Ref DatabaseBackupVault
            ScheduleExpression: 'cron(0 3 ? * SUN *)'  # 3 AM Sunday
            StartWindowMinutes: 60
            CompletionWindowMinutes: 180
            Lifecycle:
              DeleteAfterDays: 90
              MoveToColdStorageAfterDays: 30
            RecoveryPointTags:
              Environment: !Ref Environment
              BackupType: Weekly

  # Backup IAM role
  BackupRole:
    Type: AWS::IAM::Role
    Condition: IsProduction
    Properties:
      RoleName: !Sub '${ProjectName}-${Environment}-backup-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: backup.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSBackupServiceRolePolicyForBackup'
        - 'arn:aws:iam::aws:policy/service-role/AWSBackupServiceRolePolicyForRestores'

  # Backup selection for RDS
  DatabaseBackupSelection:
    Type: AWS::Backup::BackupSelection
    Condition: IsProduction
    Properties:
      BackupPlanId: !Ref DatabaseBackupPlan
      BackupSelection:
        SelectionName: !Sub '${ProjectName}-${Environment}-rds-selection'
        IamRoleArn: !GetAtt BackupRole.Arn
        Resources:
          - !Sub 'arn:aws:rds:${AWS::Region}:${AWS::AccountId}:db:${ProjectName}-${Environment}-db'
        Conditions:
          StringEquals:
            'aws:ResourceTag/Environment': !Ref Environment
            'aws:ResourceTag/Project': !Ref ProjectName

  # ==================== DISASTER RECOVERY AUTOMATION ====================
  
  # Lambda function for automated failover
  DisasterRecoveryFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${Environment}-dr-orchestrator'
      Runtime: nodejs18.x
      Handler: index.handler
      MemorySize: 512
      Timeout: 900  # 15 minutes
      ReservedConcurrencyLimit: 1
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
          PROJECT_NAME: !Ref ProjectName
          PRIMARY_REGION: !Ref PrimaryRegion
          SECONDARY_REGION: !Ref SecondaryRegion
          RTO_MINUTES: !Ref RTOMinutes
          RPO_HOURS: !Ref RPOHours
      Policies:
        - Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Action:
                - 'rds:*'
                - 'route53:*'
                - 'cloudformation:*'
                - 'lambda:*'
                - 'apigateway:*'
                - 's3:*'
                - 'elasticache:*'
                - 'backup:*'
                - 'sns:Publish'
                - 'cloudwatch:PutMetricData'
              Resource: '*'
      InlineCode: |
        const AWS = require('aws-sdk');
        
        exports.handler = async (event) => {
            console.log('Disaster Recovery Orchestrator triggered:', JSON.stringify(event, null, 2));
            
            const operation = event.operation; // 'failover', 'failback', 'test', 'status'
            
            try {
                switch (operation) {
                    case 'failover':
                        return await executeFailover(event);
                    case 'failback':
                        return await executeFailback(event);
                    case 'test':
                        return await executeDisasterRecoveryTest(event);
                    case 'status':
                        return await checkDRStatus(event);
                    default:
                        throw new Error(`Unknown operation: ${operation}`);
                }
            } catch (error) {
                console.error('DR operation failed:', error);
                await notifyDRFailure(operation, error);
                throw error;
            }
        };
        
        async function executeFailover(event) {
            console.log('Starting failover to secondary region...');
            
            const steps = [];
            const startTime = Date.now();
            
            try {
                // Step 1: Verify primary region health
                steps.push({ step: 'health_check', status: 'started', timestamp: new Date().toISOString() });
                const healthStatus = await checkPrimaryRegionHealth();
                
                if (healthStatus.healthy && !event.force) {
                    return {
                        statusCode: 400,
                        body: JSON.stringify({
                            message: 'Primary region is healthy. Use force=true to override.',
                            healthStatus: healthStatus
                        })
                    };
                }
                steps.push({ step: 'health_check', status: 'completed', timestamp: new Date().toISOString() });
                
                // Step 2: Create database snapshot for point-in-time recovery
                steps.push({ step: 'snapshot', status: 'started', timestamp: new Date().toISOString() });
                await createEmergencySnapshot();
                steps.push({ step: 'snapshot', status: 'completed', timestamp: new Date().toISOString() });
                
                // Step 3: Restore database in secondary region
                steps.push({ step: 'restore_db', status: 'started', timestamp: new Date().toISOString() });
                await restoreDatabaseInSecondaryRegion();
                steps.push({ step: 'restore_db', status: 'completed', timestamp: new Date().toISOString() });
                
                // Step 4: Deploy application infrastructure in secondary region
                steps.push({ step: 'deploy_infra', status: 'started', timestamp: new Date().toISOString() });
                await deploySecondaryRegionInfrastructure();
                steps.push({ step: 'deploy_infra', status: 'completed', timestamp: new Date().toISOString() });
                
                // Step 5: Update DNS to point to secondary region
                steps.push({ step: 'dns_failover', status: 'started', timestamp: new Date().toISOString() });
                await updateDNSForFailover();
                steps.push({ step: 'dns_failover', status: 'completed', timestamp: new Date().toISOString() });
                
                // Step 6: Verify secondary region health
                steps.push({ step: 'verify_secondary', status: 'started', timestamp: new Date().toISOString() });
                await verifySecondaryRegionHealth();
                steps.push({ step: 'verify_secondary', status: 'completed', timestamp: new Date().toISOString() });
                
                const duration = Date.now() - startTime;
                await recordDRMetrics('failover', duration, true);
                await notifyDRSuccess('failover', duration);
                
                return {
                    statusCode: 200,
                    body: JSON.stringify({
                        message: 'Failover completed successfully',
                        duration: `${Math.round(duration / 1000 / 60)} minutes`,
                        steps: steps,
                        secondaryRegion: process.env.SECONDARY_REGION
                    })
                };
                
            } catch (error) {
                const duration = Date.now() - startTime;
                await recordDRMetrics('failover', duration, false);
                throw error;
            }
        }
        
        async function executeFailback(event) {
            console.log('Starting failback to primary region...');
            
            // Similar structure to failover but in reverse
            const steps = [];
            const startTime = Date.now();
            
            try {
                // Verify primary region is restored
                steps.push({ step: 'verify_primary', status: 'started', timestamp: new Date().toISOString() });
                await verifyPrimaryRegionRestored();
                steps.push({ step: 'verify_primary', status: 'completed', timestamp: new Date().toISOString() });
                
                // Sync data from secondary to primary
                steps.push({ step: 'data_sync', status: 'started', timestamp: new Date().toISOString() });
                await syncDataToPrimary();
                steps.push({ step: 'data_sync', status: 'completed', timestamp: new Date().toISOString() });
                
                // Update DNS back to primary
                steps.push({ step: 'dns_failback', status: 'started', timestamp: new Date().toISOString() });
                await updateDNSForFailback();
                steps.push({ step: 'dns_failback', status: 'completed', timestamp: new Date().toISOString() });
                
                const duration = Date.now() - startTime;
                await recordDRMetrics('failback', duration, true);
                
                return {
                    statusCode: 200,
                    body: JSON.stringify({
                        message: 'Failback completed successfully',
                        duration: `${Math.round(duration / 1000 / 60)} minutes`,
                        steps: steps
                    })
                };
                
            } catch (error) {
                const duration = Date.now() - startTime;
                await recordDRMetrics('failback', duration, false);
                throw error;
            }
        }
        
        async function executeDisasterRecoveryTest(event) {
            console.log('Starting DR test...');
            
            // Non-destructive test of DR capabilities
            const testResults = {
                backupStatus: await validateBackups(),
                replicationStatus: await validateReplication(),
                infrastructureReadiness: await validateSecondaryInfrastructure(),
                rtoEstimate: await estimateRTO(),
                rpoEstimate: await estimateRPO()
            };
            
            const overallStatus = Object.values(testResults).every(result => result.status === 'pass');
            
            return {
                statusCode: 200,
                body: JSON.stringify({
                    message: 'DR test completed',
                    overallStatus: overallStatus ? 'pass' : 'fail',
                    results: testResults,
                    recommendations: generateDRRecommendations(testResults)
                })
            };
        }
        
        async function checkDRStatus(event) {
            return {
                statusCode: 200,
                body: JSON.stringify({
                    currentRegion: process.env.AWS_REGION,
                    primaryRegion: process.env.PRIMARY_REGION,
                    secondaryRegion: process.env.SECONDARY_REGION,
                    lastBackup: await getLastBackupInfo(),
                    replicationStatus: await getReplicationStatus(),
                    rto: `${process.env.RTO_MINUTES} minutes`,
                    rpo: `${process.env.RPO_HOURS} hours`
                })
            };
        }
        
        // Placeholder functions - implement based on specific requirements
        async function checkPrimaryRegionHealth() {
            // Check API Gateway, RDS, ElastiCache health in primary region
            return { healthy: false, issues: ['API Gateway 5xx errors'] };
        }
        
        async function createEmergencySnapshot() {
            console.log('Creating emergency database snapshot...');
            // Create RDS snapshot
        }
        
        async function restoreDatabaseInSecondaryRegion() {
            console.log('Restoring database in secondary region...');
            // Restore from latest backup in secondary region
        }
        
        async function deploySecondaryRegionInfrastructure() {
            console.log('Deploying infrastructure in secondary region...');
            // Deploy CloudFormation stack in secondary region
        }
        
        async function updateDNSForFailover() {
            console.log('Updating DNS for failover...');
            // Update Route53 records to point to secondary region
        }
        
        async function verifySecondaryRegionHealth() {
            console.log('Verifying secondary region health...');
            // Health check secondary region endpoints
        }
        
        async function recordDRMetrics(operation, duration, success) {
            const cloudwatch = new AWS.CloudWatch();
            
            await cloudwatch.putMetricData({
                Namespace: `Seawater/${process.env.ENVIRONMENT}/DR`,
                MetricData: [
                    {
                        MetricName: 'OperationDuration',
                        Value: duration,
                        Unit: 'Milliseconds',
                        Dimensions: [
                            { Name: 'Operation', Value: operation },
                            { Name: 'Success', Value: success.toString() }
                        ]
                    }
                ]
            }).promise();
        }
        
        async function notifyDRSuccess(operation, duration) {
            console.log(`DR ${operation} completed in ${duration}ms`);
            // Send notification via SNS
        }
        
        async function notifyDRFailure(operation, error) {
            console.error(`DR ${operation} failed:`, error);
            // Send critical alert via SNS
        }
        
        // Additional helper functions...
        async function validateBackups() { return { status: 'pass' }; }
        async function validateReplication() { return { status: 'pass' }; }
        async function validateSecondaryInfrastructure() { return { status: 'pass' }; }
        async function estimateRTO() { return { status: 'pass', estimate: '45 minutes' }; }
        async function estimateRPO() { return { status: 'pass', estimate: '2 hours' }; }
        async function generateDRRecommendations(results) { return []; }
        async function getLastBackupInfo() { return { timestamp: new Date().toISOString() }; }
        async function getReplicationStatus() { return { status: 'healthy' }; }
        
        // Failback helper functions
        async function verifyPrimaryRegionRestored() { console.log('Verifying primary region...'); }
        async function syncDataToPrimary() { console.log('Syncing data to primary...'); }
        async function updateDNSForFailback() { console.log('Updating DNS for failback...'); }

  # ==================== HEALTH MONITORING ====================
  
  # Multi-region health check
  DRHealthCheckFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${Environment}-dr-health-check'
      Runtime: nodejs18.x
      Handler: index.handler
      MemorySize: 256
      Timeout: 60
      Environment:
        Variables:
          PRIMARY_REGION: !Ref PrimaryRegion
          SECONDARY_REGION: !Ref SecondaryRegion
          HEALTH_CHECK_ENDPOINTS: !Sub |
            {
              "primary": "https://${ProjectName}-${Environment}-api.execute-api.${PrimaryRegion}.amazonaws.com/${Environment}/health",
              "secondary": "https://${ProjectName}-${Environment}-api.execute-api.${SecondaryRegion}.amazonaws.com/${Environment}/health"
            }
      InlineCode: |
        const https = require('https');
        const AWS = require('aws-sdk');
        const cloudwatch = new AWS.CloudWatch();
        
        exports.handler = async (event) => {
            const endpoints = JSON.parse(process.env.HEALTH_CHECK_ENDPOINTS);
            const results = {};
            
            for (const [region, url] of Object.entries(endpoints)) {
                try {
                    const startTime = Date.now();
                    const response = await healthCheck(url);
                    const duration = Date.now() - startTime;
                    
                    results[region] = {
                        healthy: response.statusCode === 200,
                        responseTime: duration,
                        statusCode: response.statusCode
                    };
                    
                    // Publish metrics
                    await cloudwatch.putMetricData({
                        Namespace: `Seawater/${process.env.ENVIRONMENT}/DR`,
                        MetricData: [
                            {
                                MetricName: 'RegionHealth',
                                Value: response.statusCode === 200 ? 1 : 0,
                                Unit: 'Count',
                                Dimensions: [{ Name: 'Region', Value: region }]
                            },
                            {
                                MetricName: 'ResponseTime',
                                Value: duration,
                                Unit: 'Milliseconds',
                                Dimensions: [{ Name: 'Region', Value: region }]
                            }
                        ]
                    }).promise();
                    
                } catch (error) {
                    results[region] = {
                        healthy: false,
                        error: error.message
                    };
                }
            }
            
            return {
                statusCode: 200,
                body: JSON.stringify(results)
            };
        };
        
        function healthCheck(url) {
            return new Promise((resolve, reject) => {
                const request = https.get(url, { timeout: 10000 }, (response) => {
                    resolve({ statusCode: response.statusCode });
                });
                
                request.on('error', reject);
                request.on('timeout', () => reject(new Error('Timeout')));
            });
        }
      Events:
        HealthCheck:
          Type: Schedule
          Properties:
            Schedule: 'rate(5 minutes)'
            Description: 'Multi-region health monitoring'

  # ==================== ROUTE 53 HEALTH CHECKS ====================
  
  PrimaryRegionHealthCheck:
    Type: AWS::Route53::HealthCheck
    Condition: IsProduction
    Properties:
      Type: HTTPS
      ResourcePath: !Sub '/${Environment}/health'
      FullyQualifiedDomainName: !Sub '${ProjectName}-${Environment}-api.execute-api.${PrimaryRegion}.amazonaws.com'
      Port: 443
      RequestInterval: 30
      FailureThreshold: 3
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-primary-health'

  SecondaryRegionHealthCheck:
    Type: AWS::Route53::HealthCheck
    Condition: IsProduction
    Properties:
      Type: HTTPS
      ResourcePath: !Sub '/${Environment}/health'
      FullyQualifiedDomainName: !Sub '${ProjectName}-${Environment}-api.execute-api.${SecondaryRegion}.amazonaws.com'
      Port: 443
      RequestInterval: 30
      FailureThreshold: 3
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-secondary-health'

  # ==================== DR RUNBOOK AUTOMATION ====================
  
  DRRunbookStepFunction:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${ProjectName}-${Environment}-dr-runbook'
      RoleArn: !GetAtt StepFunctionRole.Arn
      DefinitionString: !Sub |
        {
          "Comment": "Disaster Recovery Runbook Automation",
          "StartAt": "AssessDisaster",
          "States": {
            "AssessDisaster": {
              "Type": "Task",
              "Resource": "${DisasterRecoveryFunction.Arn}",
              "Parameters": {
                "operation": "status"
              },
              "Next": "DecideRecoveryPath"
            },
            "DecideRecoveryPath": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.primaryRegionHealthy",
                  "BooleanEquals": false,
                  "Next": "ExecuteFailover"
                }
              ],
              "Default": "MonitorSituation"
            },
            "ExecuteFailover": {
              "Type": "Task",
              "Resource": "${DisasterRecoveryFunction.Arn}",
              "Parameters": {
                "operation": "failover"
              },
              "Next": "VerifyFailover"
            },
            "VerifyFailover": {
              "Type": "Task",
              "Resource": "${DRHealthCheckFunction.Arn}",
              "Next": "NotifyStakeholders"
            },
            "NotifyStakeholders": {
              "Type": "Task",
              "Resource": "arn:aws:states:::sns:publish",
              "Parameters": {
                "TopicArn": "${DRNotificationTopic}",
                "Message": "Disaster recovery failover completed"
              },
              "End": true
            },
            "MonitorSituation": {
              "Type": "Wait",
              "Seconds": 300,
              "Next": "AssessDisaster"
            }
          }
        }

  StepFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: states.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: StepFunctionExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'lambda:InvokeFunction'
                  - 'sns:Publish'
                Resource: '*'

  # ==================== NOTIFICATIONS ====================
  
  DRNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub '${ProjectName}-${Environment}-dr-notifications'
      DisplayName: 'Disaster Recovery Notifications'

  # ==================== DR TESTING SCHEDULE ====================
  
  DRTestingFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${Environment}-dr-testing'
      Runtime: nodejs18.x
      Handler: index.handler
      MemorySize: 256
      Timeout: 300
      Environment:
        Variables:
          DR_ORCHESTRATOR_ARN: !GetAtt DisasterRecoveryFunction.Arn
      Policies:
        - Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Action:
                - 'lambda:InvokeFunction'
                - 'sns:Publish'
              Resource: '*'
      InlineCode: |
        const AWS = require('aws-sdk');
        const lambda = new AWS.Lambda();
        
        exports.handler = async (event) => {
            console.log('Starting scheduled DR test...');
            
            try {
                const result = await lambda.invoke({
                    FunctionName: process.env.DR_ORCHESTRATOR_ARN,
                    Payload: JSON.stringify({
                        operation: 'test',
                        scheduledTest: true
                    })
                }).promise();
                
                const response = JSON.parse(result.Payload);
                console.log('DR test completed:', response);
                
                return {
                    statusCode: 200,
                    body: JSON.stringify({
                        message: 'DR test completed',
                        result: response
                    })
                };
                
            } catch (error) {
                console.error('DR test failed:', error);
                throw error;
            }
        };
      Events:
        MonthlyTest:
          Type: Schedule
          Properties:
            Schedule: 'cron(0 10 1 * ? *)'  # First day of month at 10 AM
            Description: 'Monthly disaster recovery test'

Outputs:
  DisasterRecoveryFunctionArn:
    Description: 'Disaster recovery orchestrator function ARN'
    Value: !GetAtt DisasterRecoveryFunction.Arn
    Export:
      Name: !Sub '${ProjectName}-${Environment}-dr-function-arn'

  DRRunbookArn:
    Description: 'DR runbook Step Function ARN'
    Value: !Ref DRRunbookStepFunction
    Export:
      Name: !Sub '${ProjectName}-${Environment}-dr-runbook-arn'

  SecondaryDataBucketName:
    Condition: EnableCrossRegionReplication
    Description: 'Secondary region data bucket name'
    Value: !Ref SecondaryDataBucket
    Export:
      Name: !Sub '${ProjectName}-${Environment}-secondary-data-bucket'

  BackupVaultArn:
    Condition: IsProduction
    Description: 'Backup vault ARN'
    Value: !GetAtt DatabaseBackupVault.BackupVaultArn
    Export:
      Name: !Sub '${ProjectName}-${Environment}-backup-vault-arn'

  DRNotificationTopicArn:
    Description: 'DR notification topic ARN'
    Value: !Ref DRNotificationTopic
    Export:
      Name: !Sub '${ProjectName}-${Environment}-dr-notifications-topic'